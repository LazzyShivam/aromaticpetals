"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "(pages-dir-browser)/./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n/* global location */ // imports polyfill from `@next/polyfill-module` after build.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    emitter: function() {\n        return emitter;\n    },\n    hydrate: function() {\n        return hydrate;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    router: function() {\n        return router;\n    },\n    version: function() {\n        return version;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(pages-dir-browser)/./node_modules/react-dom/client.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/disable-smooth-scroll */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"(pages-dir-browser)/./node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"(pages-dir-browser)/./node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"(pages-dir-browser)/./node_modules/next/dist/client/page-loader.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"(pages-dir-browser)/./node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"(pages-dir-browser)/./node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../shared/lib/hooks-client-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(pages-dir-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"(pages-dir-browser)/./node_modules/next/dist/client/tracing/tracer.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ./components/is-next-router-error */ \"(pages-dir-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst version = \"16.1.3\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + '?' + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { PagesDevOverlayBridge } = __webpack_require__(/*! ../next-devtools/userspace/pages/pages-dev-overlay-setup */ \"(pages-dir-browser)/./node_modules/next/dist/next-devtools/userspace/pages/pages-dev-overlay-setup.js\");\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(PagesDevOverlayBridge, {\n                children: this.props.children\n            });\n        }\n    }\n}\nasync function initialize(opts = {}) {\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        _tracer.default.onSpanEnd((__webpack_require__(/*! ./tracing/report-to-socket */ \"(pages-dir-browser)/./node_modules/next/dist/client/tracing/report-to-socket.js\")[\"default\"]));\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || '';\n    self.__next_set_public_path__(`${prefix}/_next/`);\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"(pages-dir-browser)/./node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = ([r, f])=>pageLoader.routeLoader.onEntrypoint(r, f);\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById('__next');\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(App, {\n        ...appProps\n    });\n}\nfunction AppContainer({ children }) {\n    _s();\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo({\n        \"AppContainer.useMemo[adaptedForAppRouter]\": ()=>{\n            return (0, _adapters.adaptForAppRouterInstance)(router);\n        }\n    }[\"AppContainer.useMemo[adaptedForAppRouter]\"], []);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(Container, {\n        fn: (error)=>renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error('Error rendering page: ', err)),\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n            value: adaptedForAppRouter,\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                value: (0, _adapters.adaptForSearchParams)(router),\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_adapters.PathnameContextProviderAdapter, {\n                    router: router,\n                    isAutoExport: self.__NEXT_DATA__.autoExport ?? false,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                        value: (0, _adapters.adaptForPathParams)(router),\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routercontextsharedruntime.RouterContext.Provider, {\n                            value: (0, _router.makePublicRouterInstance)(router),\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n                                value: headManager,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n                                    value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[32,48,64,96,128,256,384],\"qualities\":[75,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70,70],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"images.unsplash.com\"},{\"protocol\":\"https\",\"hostname\":\"kedjdwmxhrraztmdrgfo.supabase.co\"}],\"localPatterns\":[{\"pathname\":\"**\",\"search\":\"\"}]},\n                                    children: children\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainer, {\n            children: renderApp(App, appProps)\n        });\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(`A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred`);\n    return pageLoader.loadPage('/_error').then(({ page: ErrorComponent, styleSheets })=>{\n        return lastAppProps?.Component === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"(pages-dir-browser)/./node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"(pages-dir-browser)/./node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then(({ ErrorComponent, styleSheets })=>{\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(renderErrorProps.props?.err ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head({ callback }) {\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect({\n        \"Head.useLayoutEffect\": ()=>callback()\n    }[\"Head.useLayoutEffect\"], [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nconst performanceMarks = {\n    navigationStart: 'navigationStart',\n    beforeRender: 'beforeRender',\n    afterRender: 'afterRender',\n    afterHydrate: 'afterHydrate',\n    routeChange: 'routeChange'\n};\nconst performanceMeasures = {\n    hydration: 'Next.js-hydration',\n    beforeHydration: 'Next.js-before-hydration',\n    routeChangeToRender: 'Next.js-route-change-to-render',\n    render: 'Next.js-render'\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    ;\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if ( true && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure && hydrationMeasure) {\n            _tracer.default.startSpan('navigation-to-hydration', {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, 'mark');\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.onRecoverableError\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root({ callbacks, children }) {\n    _s2();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect({\n        \"Root.useLayoutEffect\": ()=>callbacks.forEach({\n                \"Root.useLayoutEffect\": (callback)=>callback()\n            }[\"Root.useLayoutEffect\"])\n    }[\"Root.useLayoutEffect\"], [\n        callbacks\n    ]);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = Object.defineProperty(new Error('Cancel rendering route'), \"__NEXT_ERROR_CODE\", {\n                value: \"E503\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== 'production') {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute('data-n-href')));\n        const noscript = document.querySelector('noscript[data-n-css]');\n        const nonce = noscript?.getAttribute('data-n-css');\n        styleSheets.forEach(({ href, text })=>{\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n                callback: onHeadCommit\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(AppContainer, {\n                children: [\n                    renderApp(App, appProps),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_portal.Portal, {\n                        type: \"next-route-announcer\",\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routeannouncer.RouteAnnouncer, {})\n                    })\n                ]\n            })\n        ]\n    });\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ],\n            children:  false ? /*#__PURE__*/ 0 : elem\n        }));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    // if an error occurs in a server-side page (e.g. in getInitialProps),\n    // skip re-rendering the error page client-side as data-fetching operations\n    // will already have been done on the server and NEXT_DATA contains the correct\n    // data for straight-forward hydration of the error page\n    if (renderingProps.err && // renderingProps.Component might be undefined if there is a top/module-level error\n    (typeof renderingProps.Component === 'undefined' || !renderingProps.isHydratePass)) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint('/_app');\n        if ('error' in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = ({ id, name, startTime, value, duration, entryType, entries, attribution })=>{\n                // Combines timestamp with random number for unique ID\n                const uniqueID = `${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if ('error' in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${initialData.page}\"`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E286\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const getServerError = (__webpack_require__(/*! ../server/dev/node-stack-frames */ \"(pages-dir-browser)/./node_modules/next/dist/server/dev/node-stack-frames.js\").getServerError);\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw Object.defineProperty(new Error(initialErr.message), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    const errSource = initialErr.source;\n                    // In development, error the navigation API usage in runtime,\n                    // since it's not allowed to be used in pages router as it doesn't contain error boundary like app router.\n                    if ((0, _isnextroutererror.isNextRouterError)(initialErr)) {\n                        error.message = 'Next.js navigation API is not allowed to be used in Pages Router.';\n                    }\n                    throw getServerError(error, errSource);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr,\n        isHydratePass: true\n    };\n    if (opts?.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1CQUFtQixHQUNuQiw2REFBNkQ7Ozs7Ozs7Ozs7Ozs7SUF5RWhEQSxPQUFPO2VBQVBBOztJQXF2QlNDLE9BQU87ZUFBUEE7O0lBbG9CQUMsVUFBVTtlQUFWQTs7SUFwSFhDLE1BQU07ZUFBTkE7O0lBREVDLE9BQU87ZUFBUEE7Ozs7O29CQXRFTjs0RUFReUI7NkVBQ1g7NkRBQ2M7MkVBQ2xCO3dEQUVhO2lEQUMyQjt1Q0FDMUI7eUNBSXhCO21DQUN5QztvQ0FFekI7a0ZBQ0s7aUZBQ0w7NENBRVE7b0NBQ3dCO3FDQUN4Qjs2REFDSTs0Q0FFSjt5Q0FDSDsyREFDSztzQ0FNMUI7NkRBSUE7Z0RBQzRCOzZFQUNoQjsrQ0FDZTtBQXdCM0IsTUFBTUEsVUFBVUMsUUFBUUM7QUFDeEIsSUFBSUg7QUFDSixNQUFNSCxVQUErQlEsQ0FBQUEsR0FBQUEsTUFBQUEsT0FBQUE7QUFFNUMsTUFBTUMsZUFBZSxDQUFlQyxRQUFvQixFQUFFLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDRjtBQUV0RSxJQUFJRztBQUNKLElBQUlDLGdCQUFvQ0M7QUFDeEMsSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDO0FBQ0osSUFBSUM7QUFLSixJQUFJQywyQkFBMkI7QUFDL0IsSUFBSUM7QUFFSixJQUFJQztBQUNKLElBQUlDO0FBRUosSUFBSUMsV0FBeUJDO0FBQzdCLElBQUlDO0FBRUosTUFBTUMsa0JBQWtCQyxPQUFBQSxPQUFLLENBQUNDLFNBQVM7SUFJckNDLGtCQUFrQkMsWUFBbUIsRUFBRUMsSUFBUyxFQUFFO1FBQ2hELElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxFQUFFLENBQUNILGNBQWNDO0lBQzlCO0lBRUFHLG9CQUFvQjtRQUNsQixJQUFJLENBQUNDLFlBQVk7UUFFakIsMENBQTBDO1FBQzFDLHlFQUF5RTtRQUN6RSxvRUFB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T3dLO2dCQUM5QjtZQUNGLE9BR0s7Z0JBQ0hsTyxXQUFXO29CQUNULE1BQU13TTtnQkFDUjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLElBQUkxTCxPQUFPdU4sbUJBQW1CLEVBQUU7UUFDOUIsTUFBTXZOLE9BQU91TixtQkFBbUIsQ0FBQ3ZSLFlBQVl3UixVQUFVO0lBQ3pEO0lBRUFsUyxTQUFTbVMsQ0FBQUEsR0FBQUEsUUFBQUEsWUFBQUEsRUFBYXpSLFlBQVlzSSxJQUFJLEVBQUV0SSxZQUFZcUMsS0FBSyxFQUFFbEMsUUFBUTtRQUNqRXVSLGNBQWMxUixZQUFZb0IsS0FBSztRQUMvQmhCO1FBQ0FrRyxLQUFLM0Y7UUFDTEssV0FBV0g7UUFDWGlIO1FBQ0FwRixLQUFLZ047UUFDTGpPLFlBQVlrUSxRQUFRM1IsWUFBWXlCLFVBQVU7UUFDMUNtUSxjQUFjLENBQUN6USxNQUFNbUYsS0FBS29JLFNBQ3hCdEwsT0FDRXlPLE9BQU8xUCxNQUFNLENBSVgsQ0FBQyxHQUFHaEIsTUFBTTtnQkFDVm1GO2dCQUNBb0k7WUFDRjtRQUVKeEosUUFBUWxGLFlBQVlrRixNQUFNO1FBQzFCSixTQUFTOUUsWUFBWThFLE9BQU87UUFDNUI3RTtRQUNBNlIsZUFBZTlSLFlBQVk4UixhQUFhO1FBQ3hDQyxXQUFXL1IsWUFBWStSLFNBQVM7SUFDbEM7SUFFQXhSLDJCQUEyQixNQUFNakIsT0FBTzBTLGdDQUFnQztJQUV4RSxNQUFNQyxZQUE2QjtRQUNqQzNMLEtBQUszRjtRQUNMdVIsU0FBUztRQUNUbFIsV0FBV0g7UUFDWE8sT0FBT3BCLFlBQVlvQixLQUFLO1FBQ3hCc0IsS0FBS2dOO1FBQ0xILGVBQWU7SUFDakI7SUFFQSxJQUFJOUwsTUFBTThGLGNBQWM7UUFDdEIsTUFBTTlGLEtBQUs4RixZQUFZO0lBQ3pCO0lBRUFuRyxPQUFPNk87QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL3NyYy9jbGllbnQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBsb2NhdGlvbiAqL1xuLy8gaW1wb3J0cyBwb2x5ZmlsbCBmcm9tIGBAbmV4dC9wb2x5ZmlsbC1tb2R1bGVgIGFmdGVyIGJ1aWxkLlxuaW1wb3J0ICcuLi9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlJ1xuaW1wb3J0IHR5cGUgUm91dGVyIGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHtcbiAgQXBwQ29tcG9uZW50LFxuICBBcHBQcm9wcyxcbiAgUHJpdmF0ZVJvdXRlSW5mbyxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyJ1xuXG5pbXBvcnQgUmVhY3QsIHsgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCBtaXR0IGZyb20gJy4uL3NoYXJlZC9saWIvbWl0dCdcbmltcG9ydCB0eXBlIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9zaGFyZWQvbGliL21pdHQnXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24gfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9kaXNhYmxlLXNtb290aC1zY3JvbGwnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQge1xuICB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zLFxuICBhc3NpZ24sXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgZ2V0VVJMLCBsb2FkR2V0SW5pdGlhbFByb3BzLCBTVCB9IGZyb20gJy4uL3NoYXJlZC9saWIvdXRpbHMnXG5pbXBvcnQgdHlwZSB7IE5leHRXZWJWaXRhbHNNZXRyaWMsIE5FWFRfREFUQSB9IGZyb20gJy4uL3NoYXJlZC9saWIvdXRpbHMnXG5pbXBvcnQgeyBQb3J0YWwgfSBmcm9tICcuL3BvcnRhbCdcbmltcG9ydCBpbml0SGVhZE1hbmFnZXIgZnJvbSAnLi9oZWFkLW1hbmFnZXInXG5pbXBvcnQgUGFnZUxvYWRlciBmcm9tICcuL3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHR5cGUgeyBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuL3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHsgUm91dGVBbm5vdW5jZXIgfSBmcm9tICcuL3JvdXRlLWFubm91bmNlcidcbmltcG9ydCB7IGNyZWF0ZVJvdXRlciwgbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyBnZXRQcm9wZXJFcnJvciB9IGZyb20gJy4uL2xpYi9pcy1lcnJvcidcbmltcG9ydCB7IEltYWdlQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEltYWdlQ29uZmlnQ29tcGxldGUgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuL2hhcy1iYXNlLXBhdGgnXG5pbXBvcnQgeyBBcHBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlLFxuICBhZGFwdEZvclBhdGhQYXJhbXMsXG4gIGFkYXB0Rm9yU2VhcmNoUGFyYW1zLFxuICBQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL2FkYXB0ZXJzJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aFBhcmFtc0NvbnRleHQsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBvblJlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuL3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3InXG5pbXBvcnQgdHJhY2VyIGZyb20gJy4vdHJhY2luZy90cmFjZXInXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4vY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC1kb20vZXhwZXJpbWVudGFsXCIgLz5cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAvKiB0ZXN0IGZucyAqL1xuICAgIF9fTkVYVF9IWURSQVRFRD86IGJvb2xlYW5cbiAgICBfX05FWFRfSFlEUkFURURfQVQ/OiBudW1iZXJcbiAgICBfX05FWFRfSFlEUkFURURfQ0I/OiAoKSA9PiB2b2lkXG5cbiAgICAvKiBwcm9kICovXG4gICAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gICAgX19ORVhUX1A6IGFueVtdXG4gIH1cbn1cbnR5cGUgUmVuZGVyUm91dGVJbmZvID0gUHJpdmF0ZVJvdXRlSW5mbyAmIHtcbiAgQXBwOiBBcHBDb21wb25lbnRcbiAgc2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICBpc0h5ZHJhdGVQYXNzPzogYm9vbGVhblxufVxudHlwZSBSZW5kZXJFcnJvclByb3BzID0gT21pdDxSZW5kZXJSb3V0ZUluZm8sICdDb21wb25lbnQnIHwgJ3N0eWxlU2hlZXRzJz5cbnR5cGUgUmVnaXN0ZXJGbiA9IChpbnB1dDogW3N0cmluZywgKCkgPT4gdm9pZF0pID0+IHZvaWRcblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfVkVSU0lPTlxuZXhwb3J0IGxldCByb3V0ZXI6IFJvdXRlclxuZXhwb3J0IGNvbnN0IGVtaXR0ZXI6IE1pdHRFbWl0dGVyPHN0cmluZz4gPSBtaXR0KClcblxuY29uc3QgbG9vc2VUb0FycmF5ID0gPFQgZXh0ZW5kcyB7fT4oaW5wdXQ6IGFueSk6IFRbXSA9PiBbXS5zbGljZS5jYWxsKGlucHV0KVxuXG5sZXQgaW5pdGlhbERhdGE6IE5FWFRfREFUQVxubGV0IGRlZmF1bHRMb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxubGV0IGFzUGF0aDogc3RyaW5nXG5sZXQgcGFnZUxvYWRlcjogUGFnZUxvYWRlclxubGV0IGFwcEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbFxubGV0IGhlYWRNYW5hZ2VyOiB7XG4gIG1vdW50ZWRJbnN0YW5jZXM6IFNldDx1bmtub3duPlxuICB1cGRhdGVIZWFkOiAoaGVhZDogSlNYLkVsZW1lbnRbXSkgPT4gdm9pZFxuICBnZXRJc1Nzcj86ICgpID0+IGJvb2xlYW5cbn1cbmxldCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBmYWxzZVxubGV0IGxhc3RBcHBQcm9wczogQXBwUHJvcHNcblxubGV0IGxhc3RSZW5kZXJSZWplY3Q6ICgoKSA9PiB2b2lkKSB8IG51bGxcbmxldCBkZXZDbGllbnQ6IGFueVxuXG5sZXQgQ2FjaGVkQXBwOiBBcHBDb21wb25lbnQsIG9uUGVyZkVudHJ5OiAobWV0cmljOiBhbnkpID0+IHZvaWRcbmxldCBDYWNoZWRDb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGVcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZm46IChlcnI6IEVycm9yLCBpbmZvPzogYW55KSA9PiB2b2lkXG59PiB7XG4gIGNvbXBvbmVudERpZENhdGNoKGNvbXBvbmVudEVycjogRXJyb3IsIGluZm86IGFueSkge1xuICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zY3JvbGxUb0hhc2goKVxuXG4gICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSByb3V0ZXIgc3RhdGUgaWY6XG4gICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgLy8gLSBpZiBpdCBpcyBhIGNsaWVudC1zaWRlIHNrZWxldG9uIChmYWxsYmFjayByZW5kZXIpXG4gICAgLy8gLSBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgdGhlIGN1cnJlbnQgcGFnZSAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgLy8gLSBpZiByZXdyaXRlcyBpbiBuZXh0LmNvbmZpZy5qcyBtYXRjaCAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgaWYgKFxuICAgICAgcm91dGVyLmlzU3NyICYmXG4gICAgICAoaW5pdGlhbERhdGEuaXNGYWxsYmFjayB8fFxuICAgICAgICAoaW5pdGlhbERhdGEubmV4dEV4cG9ydCAmJlxuICAgICAgICAgIChpc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8XG4gICAgICAgICAgICBsb2NhdGlvbi5zZWFyY2ggfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHxcbiAgICAgICAgICAgIGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpIHx8XG4gICAgICAgIChpbml0aWFsRGF0YS5wcm9wcyAmJlxuICAgICAgICAgIGluaXRpYWxEYXRhLnByb3BzLl9fTl9TU0cgJiZcbiAgICAgICAgICAobG9jYXRpb24uc2VhcmNoIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8XG4gICAgICAgICAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpKSlcbiAgICApIHtcbiAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgIHJvdXRlclxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICByb3V0ZXIucGF0aG5hbWUgK1xuICAgICAgICAgICAgJz8nICtcbiAgICAgICAgICAgIFN0cmluZyhcbiAgICAgICAgICAgICAgYXNzaWduKFxuICAgICAgICAgICAgICAgIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocm91dGVyLnF1ZXJ5KSxcbiAgICAgICAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qc1xuICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICBfaDogMSxcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHBhZ2VzIG11c3QgdHJpZ2dlciB0aGUgZGF0YSBmZXRjaCwgc28gdGhlIHRyYW5zaXRpb24gaXNcbiAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgLy8gT3RoZXIgcGFnZXMgKHN0cmljdGx5IHVwZGF0aW5nIHF1ZXJ5KSBoYXBwZW5zIHNoYWxsb3dseSwgYXMgZGF0YVxuICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIHdvdWxkIGFscmVhZHkgYmUgcHJlc2VudC5cbiAgICAgICAgICAgIHNoYWxsb3c6ICFpbml0aWFsRGF0YS5pc0ZhbGxiYWNrICYmICFpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIuY2FuY2VsbGVkKSB0aHJvdyBlcnJcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5zY3JvbGxUb0hhc2goKVxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKCkge1xuICAgIGxldCB7IGhhc2ggfSA9IGxvY2F0aW9uXG4gICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSlcbiAgICBpZiAoIWhhc2gpIHJldHVyblxuXG4gICAgY29uc3QgZWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKCFlbCkgcmV0dXJuXG5cbiAgICAvLyBJZiB3ZSBjYWxsIHNjcm9sbEludG9WaWV3KCkgaW4gaGVyZSB3aXRob3V0IGEgc2V0VGltZW91dFxuICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGVsLnNjcm9sbEludG9WaWV3KCksIDApXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgUGFnZXNEZXZPdmVybGF5QnJpZGdlIH0gPVxuICAgICAgICByZXF1aXJlKCcuLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9wYWdlcy9wYWdlcy1kZXYtb3ZlcmxheS1zZXR1cCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL3BhZ2VzL3BhZ2VzLWRldi1vdmVybGF5LXNldHVwJylcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxQYWdlc0Rldk92ZXJsYXlCcmlkZ2U+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9QYWdlc0Rldk92ZXJsYXlCcmlkZ2U+XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHM6IHsgZGV2Q2xpZW50PzogYW55IH0gPSB7fSk6IFByb21pc2U8e1xuICBhc3NldFByZWZpeDogc3RyaW5nXG59PiB7XG4gIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGlzIHNwZWNpZmljIGxpbmVzIGFyZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgdHJhY2VyLm9uU3BhbkVuZChcbiAgICAgIChcbiAgICAgICAgcmVxdWlyZSgnLi90cmFjaW5nL3JlcG9ydC10by1zb2NrZXQnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3RyYWNpbmcvcmVwb3J0LXRvLXNvY2tldCcpXG4gICAgICApLmRlZmF1bHRcbiAgICApXG4gICAgZGV2Q2xpZW50ID0gb3B0cy5kZXZDbGllbnRcbiAgfVxuXG4gIGluaXRpYWxEYXRhID0gSlNPTi5wYXJzZShcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpIS50ZXh0Q29udGVudCFcbiAgKVxuICB3aW5kb3cuX19ORVhUX0RBVEFfXyA9IGluaXRpYWxEYXRhXG5cbiAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmRlZmF1bHRMb2NhbGVcbiAgY29uc3QgcHJlZml4OiBzdHJpbmcgPSBpbml0aWFsRGF0YS5hc3NldFByZWZpeCB8fCAnJ1xuICAvLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4gIC8vIFNvLCB0aGlzIGlzIGhvdyB3ZSBkbyBpdCBpbiB0aGUgY2xpZW50IHNpZGUgYXQgcnVudGltZVxuICA7KHNlbGYgYXMgYW55KS5fX25leHRfc2V0X3B1YmxpY19wYXRoX18oYCR7cHJlZml4fS9fbmV4dC9gKVxuXG4gIGFzUGF0aCA9IGdldFVSTCgpXG5cbiAgLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuICBpZiAoaGFzQmFzZVBhdGgoYXNQYXRoKSkge1xuICAgIGFzUGF0aCA9IHJlbW92ZUJhc2VQYXRoKGFzUGF0aClcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKVxuXG4gICAgY29uc3QgeyBkZXRlY3REb21haW5Mb2NhbGUgfSA9XG4gICAgICByZXF1aXJlKCcuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKVxuXG4gICAgY29uc3QgeyBwYXJzZVJlbGF0aXZlVXJsIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJylcblxuICAgIGNvbnN0IHsgZm9ybWF0VXJsIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnKVxuXG4gICAgaWYgKGluaXRpYWxEYXRhLmxvY2FsZXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIGluaXRpYWxEYXRhLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlcml2ZSB0aGUgZGVmYXVsdCBsb2NhbGUgaWYgaXQgd2Fzbid0IGRldGVjdGVkIGluIHRoZSBhc1BhdGhcbiAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgcHJlcmVuZGVyIHN0YXRpYyBwYWdlcyB3aXRoIGFsbCBwb3NzaWJsZSBkZWZhdWx0XG4gICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICAvLyBhdHRlbXB0IGRldGVjdGluZyBkZWZhdWx0IGxvY2FsZSBiYXNlZCBvbiBob3N0bmFtZVxuICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX0RPTUFJTlMgYXMgYW55LFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVcbiAgICAgIClcblxuICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgIC8vIGh5ZHJhdGlvbiB0byBwcmV2ZW50IG1pc21hdGNoZWQgcmVuZGVyc1xuICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgIGRlZmF1bHRMb2NhbGUgPSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcikge1xuICAgIGNvbnN0IHsgaW5pdFNjcmlwdExvYWRlciB9ID1cbiAgICAgIHJlcXVpcmUoJy4vc2NyaXB0JykgYXMgdHlwZW9mIGltcG9ydCgnLi9zY3JpcHQnKVxuICAgIGluaXRTY3JpcHRMb2FkZXIoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKVxuICB9XG5cbiAgcGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKGluaXRpYWxEYXRhLmJ1aWxkSWQsIHByZWZpeClcblxuICBjb25zdCByZWdpc3RlcjogUmVnaXN0ZXJGbiA9IChbciwgZl0pID0+XG4gICAgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci5vbkVudHJ5cG9pbnQociwgZilcbiAgaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApID0+IHNldFRpbWVvdXQoKCkgPT4gcmVnaXN0ZXIocCksIDApKVxuICB9XG4gIHdpbmRvdy5fX05FWFRfUCA9IFtdXG4gIDsod2luZG93Ll9fTkVYVF9QIGFzIGFueSkucHVzaCA9IHJlZ2lzdGVyXG5cbiAgaGVhZE1hbmFnZXIgPSBpbml0SGVhZE1hbmFnZXIoKVxuICBoZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpID0+IHtcbiAgICByZXR1cm4gcm91dGVyLmlzU3NyXG4gIH1cblxuICBhcHBFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dCcpXG4gIHJldHVybiB7IGFzc2V0UHJlZml4OiBwcmVmaXggfVxufVxuXG5mdW5jdGlvbiByZW5kZXJBcHAoQXBwOiBBcHBDb21wb25lbnQsIGFwcFByb3BzOiBBcHBQcm9wcykge1xuICByZXR1cm4gPEFwcCB7Li4uYXBwUHJvcHN9IC8+XG59XG5cbmZ1bmN0aW9uIEFwcENvbnRhaW5lcih7XG4gIGNoaWxkcmVuLFxufTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e30+KTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgLy8gQ3JlYXRlIGEgbWVtb2l6ZWQgdmFsdWUgZm9yIG5leHQvbmF2aWdhdGlvbiByb3V0ZXIgY29udGV4dC5cbiAgY29uc3QgYWRhcHRlZEZvckFwcFJvdXRlciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgfSwgW10pXG4gIHJldHVybiAoXG4gICAgPENvbnRhaW5lclxuICAgICAgZm49eyhlcnJvcikgPT5cbiAgICAgICAgcmVuZGVyRXJyb3IoeyBBcHA6IENhY2hlZEFwcCwgZXJyOiBlcnJvciB9KS5jYXRjaCgoZXJyKSA9PlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA+XG4gICAgICA8QXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17YWRhcHRlZEZvckFwcFJvdXRlcn0+XG4gICAgICAgIDxTZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthZGFwdEZvclNlYXJjaFBhcmFtcyhyb3V0ZXIpfT5cbiAgICAgICAgICA8UGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyXG4gICAgICAgICAgICByb3V0ZXI9e3JvdXRlcn1cbiAgICAgICAgICAgIGlzQXV0b0V4cG9ydD17c2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQgPz8gZmFsc2V9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFBhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthZGFwdEZvclBhdGhQYXJhbXMocm91dGVyKX0+XG4gICAgICAgICAgICAgIDxSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXttYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKX0+XG4gICAgICAgICAgICAgICAgPEhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aGVhZE1hbmFnZXJ9PlxuICAgICAgICAgICAgICAgICAgPEltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fX05FWFRfSU1BR0VfT1BUUyBhcyBhbnkgYXMgSW1hZ2VDb25maWdDb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgIDwvSW1hZ2VDb25maWdDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDwvSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICA8L1JvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L1BhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyPlxuICAgICAgICA8L1NlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0FwcFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9Db250YWluZXI+XG4gIClcbn1cblxuY29uc3Qgd3JhcEFwcCA9XG4gIChBcHA6IEFwcENvbXBvbmVudCkgPT5cbiAgKHdyYXBwZWRBcHBQcm9wczogUmVjb3JkPHN0cmluZywgYW55Pik6IEpTWC5FbGVtZW50ID0+IHtcbiAgICBjb25zdCBhcHBQcm9wczogQXBwUHJvcHMgPSB7XG4gICAgICAuLi53cmFwcGVkQXBwUHJvcHMsXG4gICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgIGVycjogaW5pdGlhbERhdGEuZXJyLFxuICAgICAgcm91dGVyLFxuICAgIH1cbiAgICByZXR1cm4gPEFwcENvbnRhaW5lcj57cmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpfTwvQXBwQ29udGFpbmVyPlxuICB9XG5cbi8vIFRoaXMgbWV0aG9kIGhhbmRsZXMgYWxsIHJ1bnRpbWUgYW5kIGRlYnVnIGVycm9ycy5cbi8vIDQwNCBhbmQgNTAwIGVycm9ycyBhcmUgc3BlY2lhbCBraW5kIG9mIGVycm9yc1xuLy8gYW5kIHRoZXkgYXJlIHN0aWxsIGhhbmRsZSB2aWEgdGhlIG1haW4gcmVuZGVyIG1ldGhvZC5cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHM6IFJlbmRlckVycm9yUHJvcHMpOiBQcm9taXNlPGFueT4ge1xuICBsZXQgeyBBcHAsIGVyciB9ID0gcmVuZGVyRXJyb3JQcm9wc1xuXG4gIC8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbiAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBBIE5leHQuanMgcmVuZGVyaW5nIHJ1bnRpbWUgZXJyb3IgaXMgYWx3YXlzIHVucmVjb3ZlcmFibGVcbiAgICAvLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG4gICAgZGV2Q2xpZW50Lm9uVW5yZWNvdmVyYWJsZUVycm9yKClcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IDxBcHA+IHNvIHRoYXQgdGhlIGA8UmVhY3REZXZPdmVybGF5PmAgY2FuXG4gICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgQXBwOiAoKSA9PiBudWxsLFxuICAgICAgcHJvcHM6IHt9LFxuICAgICAgQ29tcG9uZW50OiAoKSA9PiBudWxsLFxuICAgICAgc3R5bGVTaGVldHM6IFtdLFxuICAgIH0pXG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICBjb25zb2xlLmVycm9yKGVycilcbiAgY29uc29sZS5lcnJvcihcbiAgICBgQSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkLCBzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9jbGllbnQtc2lkZS1leGNlcHRpb24tb2NjdXJyZWRgXG4gIClcblxuICByZXR1cm4gcGFnZUxvYWRlclxuICAgIC5sb2FkUGFnZSgnL19lcnJvcicpXG4gICAgLnRoZW4oKHsgcGFnZTogRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0pID0+IHtcbiAgICAgIHJldHVybiBsYXN0QXBwUHJvcHM/LkNvbXBvbmVudCA9PT0gRXJyb3JDb21wb25lbnRcbiAgICAgICAgPyBpbXBvcnQoJy4uL3BhZ2VzL19lcnJvcicpXG4gICAgICAgICAgICAudGhlbigoZXJyb3JNb2R1bGUpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vcGFnZXMvX2FwcCcpLnRoZW4oKGFwcE1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFwcCA9IGFwcE1vZHVsZS5kZWZhdWx0IGFzIGFueSBhcyBBcHBDb21wb25lbnRcbiAgICAgICAgICAgICAgICByZW5kZXJFcnJvclByb3BzLkFwcCA9IEFwcFxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1vZHVsZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChtKSA9PiAoe1xuICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0IGFzIFJlYWN0LkNvbXBvbmVudFR5cGU8e30+LFxuICAgICAgICAgICAgICBzdHlsZVNoZWV0czogW10sXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgOiB7IEVycm9yQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9XG4gICAgfSlcbiAgICAudGhlbigoeyBFcnJvckNvbXBvbmVudCwgc3R5bGVTaGVldHMgfSkgPT4ge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBkbyBhIG5vcm1hbCByZW5kZXIgd2l0aCB0aGUgYEVycm9yQ29tcG9uZW50YCBhcyBjb21wb25lbnQuXG4gICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICBjb25zdCBBcHBUcmVlID0gd3JhcEFwcChBcHApXG4gICAgICBjb25zdCBhcHBDdHggPSB7XG4gICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgIEFwcFRyZWUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgY3R4OiB7XG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIHJlbmRlckVycm9yUHJvcHMucHJvcHM/LmVyclxuICAgICAgICAgID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wc1xuICAgICAgICAgIDogbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGFwcEN0eClcbiAgICAgICkudGhlbigoaW5pdFByb3BzKSA9PlxuICAgICAgICBkb1JlbmRlcih7XG4gICAgICAgICAgLi4ucmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICBwcm9wczogaW5pdFByb3BzLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG59XG5cbi8vIER1bW15IGNvbXBvbmVudCB0aGF0IHdlIHJlbmRlciBhcyBhIGNoaWxkIG9mIFJvb3Qgc28gdGhhdCB3ZSBjYW5cbi8vIHRvZ2dsZSB0aGUgY29ycmVjdCBzdHlsZXMgYmVmb3JlIHRoZSBwYWdlIGlzIHJlbmRlcmVkLlxuZnVuY3Rpb24gSGVhZCh7IGNhbGxiYWNrIH06IHsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfSk6IG51bGwge1xuICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGNhbGxiYWNrKCksIFtjYWxsYmFja10pXG4gIHJldHVybiBudWxsXG59XG5cbmNvbnN0IHBlcmZvcm1hbmNlTWFya3MgPSB7XG4gIG5hdmlnYXRpb25TdGFydDogJ25hdmlnYXRpb25TdGFydCcsXG4gIGJlZm9yZVJlbmRlcjogJ2JlZm9yZVJlbmRlcicsXG4gIGFmdGVyUmVuZGVyOiAnYWZ0ZXJSZW5kZXInLFxuICBhZnRlckh5ZHJhdGU6ICdhZnRlckh5ZHJhdGUnLFxuICByb3V0ZUNoYW5nZTogJ3JvdXRlQ2hhbmdlJyxcbn0gYXMgY29uc3RcblxuY29uc3QgcGVyZm9ybWFuY2VNZWFzdXJlcyA9IHtcbiAgaHlkcmF0aW9uOiAnTmV4dC5qcy1oeWRyYXRpb24nLFxuICBiZWZvcmVIeWRyYXRpb246ICdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLFxuICByb3V0ZUNoYW5nZVRvUmVuZGVyOiAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgcmVuZGVyOiAnTmV4dC5qcy1yZW5kZXInLFxufSBhcyBjb25zdFxuXG5sZXQgcmVhY3RSb290OiBhbnkgPSBudWxsXG4vLyBPbiBpbml0aWFsIHJlbmRlciBhIGh5ZHJhdGUgc2hvdWxkIGFsd2F5cyBoYXBwZW5cbmxldCBzaG91bGRIeWRyYXRlOiBib29sZWFuID0gdHJ1ZVxuXG5mdW5jdGlvbiBjbGVhck1hcmtzKCk6IHZvaWQge1xuICA7W1xuICAgIHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlLFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXIsXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSxcbiAgXS5mb3JFYWNoKChtYXJrKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmspKVxufVxuXG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCk6IHZvaWQge1xuICBpZiAoIVNUKSByZXR1cm5cblxuICBwZXJmb3JtYW5jZS5tYXJrKHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cblxuICBjb25zdCBoYXNCZWZvcmVSZW5kZXJNYXJrID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAnbWFyaydcbiAgKS5sZW5ndGhcbiAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICBjb25zdCBiZWZvcmVIeWRyYXRpb25NZWFzdXJlID0gcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMuYmVmb3JlSHlkcmF0aW9uLFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5uYXZpZ2F0aW9uU3RhcnQsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlclxuICAgIClcblxuICAgIGNvbnN0IGh5ZHJhdGlvbk1lYXN1cmUgPSBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5oeWRyYXRpb24sXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIC8vIE9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkgZG9uJ3QgcmV0dXJuIGBQZXJmb3JtYW5jZU1lYXN1cmVgcyBmcm9tIGBwZXJmb3JtYW5jZS5tZWFzdXJlKClgXG4gICAgICBiZWZvcmVIeWRyYXRpb25NZWFzdXJlICYmXG4gICAgICBoeWRyYXRpb25NZWFzdXJlXG4gICAgKSB7XG4gICAgICB0cmFjZXJcbiAgICAgICAgLnN0YXJ0U3BhbignbmF2aWdhdGlvbi10by1oeWRyYXRpb24nLCB7XG4gICAgICAgICAgc3RhcnRUaW1lOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnk6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAuZW5kKFxuICAgICAgICAgIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gK1xuICAgICAgICAgICAgaHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUgK1xuICAgICAgICAgICAgaHlkcmF0aW9uTWVhc3VyZS5kdXJhdGlvblxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgcGVyZm9ybWFuY2VcbiAgICAgIC5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWVhc3VyZXMuaHlkcmF0aW9uKVxuICAgICAgLmZvckVhY2gob25QZXJmRW50cnkpXG4gIH1cbiAgY2xlYXJNYXJrcygpXG59XG5cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpOiB2b2lkIHtcbiAgaWYgKCFTVCkgcmV0dXJuXG5cbiAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgY29uc3QgbmF2U3RhcnRFbnRyaWVzOiBQZXJmb3JtYW5jZUVudHJ5TGlzdCA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSxcbiAgICAnbWFyaydcbiAgKVxuXG4gIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkgcmV0dXJuXG5cbiAgY29uc3QgaGFzQmVmb3JlUmVuZGVyTWFyayA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgJ21hcmsnXG4gICkubGVuZ3RoXG5cbiAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyLFxuICAgICAgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlclxuICAgIClcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yZW5kZXIsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXJcbiAgICApXG4gICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICBwZXJmb3JtYW5jZVxuICAgICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcilcbiAgICAgICAgLmZvckVhY2gob25QZXJmRW50cnkpXG4gICAgICBwZXJmb3JtYW5jZVxuICAgICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJvdXRlQ2hhbmdlVG9SZW5kZXIpXG4gICAgICAgIC5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyTWFya3MoKVxuICA7W1xuICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMucm91dGVDaGFuZ2VUb1JlbmRlcixcbiAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcixcbiAgXS5mb3JFYWNoKChtZWFzdXJlKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKVxufVxuXG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoXG4gIGRvbUVsOiBIVE1MRWxlbWVudCxcbiAgZm46IChjYjogKCkgPT4gdm9pZCkgPT4gSlNYLkVsZW1lbnRcbik6IHZvaWQge1xuICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gIGlmIChTVCkge1xuICAgIHBlcmZvcm1hbmNlLm1hcmsocGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIpXG4gIH1cblxuICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpXG4gIGlmICghcmVhY3RSb290KSB7XG4gICAgLy8gVW5saWtlIHdpdGggY3JlYXRlUm9vdCwgeW91IGRvbid0IG5lZWQgYSBzZXBhcmF0ZSByb290LnJlbmRlcigpIGNhbGwgaGVyZVxuICAgIHJlYWN0Um9vdCA9IFJlYWN0RE9NLmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsLCB7XG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgfSlcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgc2hvdWxkSHlkcmF0ZSA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gKFJlYWN0IGFzIGFueSkuc3RhcnRUcmFuc2l0aW9uXG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbClcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIFJvb3Qoe1xuICBjYWxsYmFja3MsXG4gIGNoaWxkcmVuLFxufTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBjYWxsYmFja3M6IEFycmF5PCgpID0+IHZvaWQ+XG59Pik6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGVcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KFxuICAgICgpID0+IGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSksXG4gICAgW2NhbGxiYWNrc11cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0FUID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQigpXG4gICAgICB9XG4gICAgfSwgW10pXG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW4gYXMgUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGRvUmVuZGVyKGlucHV0OiBSZW5kZXJSb3V0ZUluZm8pOiBQcm9taXNlPGFueT4ge1xuICBsZXQgeyBBcHAsIENvbXBvbmVudCwgcHJvcHMsIGVyciB9OiBSZW5kZXJSb3V0ZUluZm8gPSBpbnB1dFxuICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdIHwgdW5kZWZpbmVkID1cbiAgICAnaW5pdGlhbCcgaW4gaW5wdXQgPyB1bmRlZmluZWQgOiBpbnB1dC5zdHlsZVNoZWV0c1xuICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudFxuICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wc1xuXG4gIGNvbnN0IGFwcFByb3BzOiBBcHBQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICBDb21wb25lbnQsXG4gICAgZXJyLFxuICAgIHJvdXRlcixcbiAgfVxuICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICBsYXN0QXBwUHJvcHMgPSBhcHBQcm9wc1xuXG4gIGxldCBjYW5jZWxlZDogYm9vbGVhbiA9IGZhbHNlXG4gIGxldCByZXNvbHZlUHJvbWlzZTogKCkgPT4gdm9pZFxuICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChsYXN0UmVuZGVyUmVqZWN0KSB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0KClcbiAgICB9XG4gICAgcmVzb2x2ZVByb21pc2UgPSAoKSA9PiB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGxhc3RSZW5kZXJSZWplY3QgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxlZCA9IHRydWVcbiAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsXG5cbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ0NhbmNlbCByZW5kZXJpbmcgcm91dGUnKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgcmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfSlcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gIC8vIFByb21pc2UuIEl0IHNob3VsZCByZW1haW4gc3luY2hyb25vdXMuXG4gIGZ1bmN0aW9uIG9uU3RhcnQoKTogYm9vbGVhbiB7XG4gICAgaWYgKFxuICAgICAgIXN0eWxlU2hlZXRzIHx8XG4gICAgICAvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFN0eWxlVGFnczogSFRNTFN0eWxlRWxlbWVudFtdID0gbG9vc2VUb0FycmF5PEhUTUxTdHlsZUVsZW1lbnQ+KFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJylcbiAgICApXG4gICAgY29uc3QgY3VycmVudEhyZWZzOiBTZXQ8c3RyaW5nIHwgbnVsbD4gPSBuZXcgU2V0KFxuICAgICAgY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZykgPT4gdGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKSlcbiAgICApXG5cbiAgICBjb25zdCBub3NjcmlwdDogRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJ25vc2NyaXB0W2RhdGEtbi1jc3NdJ1xuICAgIClcbiAgICBjb25zdCBub25jZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCA9XG4gICAgICBub3NjcmlwdD8uZ2V0QXR0cmlidXRlKCdkYXRhLW4tY3NzJylcblxuICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiwgdGV4dCB9OiB7IGhyZWY6IHN0cmluZzsgdGV4dDogYW55IH0pID0+IHtcbiAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicsIGhyZWYpXG4gICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpXG5cbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZylcbiAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIC8vIFR1cmJvcGFjayBoYXMgaXQncyBvd24gY3NzIGluamVjdGlvbiBoYW5kbGluZywgdGhpcyBjb2RlIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIENTUy5cbiAgICAgICFwcm9jZXNzLmVudi5UVVJCT1BBQ0sgJiZcbiAgICAgIC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgLy8gdW5sZXNzIHdlJ3JlIGluIHByb2R1Y3Rpb246XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAvLyBXZSBjYW4gc2tpcCB0aGlzIGR1cmluZyBoeWRyYXRpb24uIFJ1bm5pbmcgaXQgd29udCBjYXVzZSBhbnkgaGFybSwgYnV0XG4gICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgc3R5bGVTaGVldHMgJiZcbiAgICAgIC8vIEVuc3VyZSB0aGlzIHJlbmRlciB3YXMgbm90IGNhbmNlbGVkXG4gICAgICAhY2FuY2VsZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IGRlc2lyZWRIcmVmczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KHN0eWxlU2hlZXRzLm1hcCgocykgPT4gcy5ocmVmKSlcbiAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3M6IEhUTUxTdHlsZUVsZW1lbnRbXSA9XG4gICAgICAgIGxvb3NlVG9BcnJheTxIVE1MU3R5bGVFbGVtZW50PihcbiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKVxuICAgICAgICApXG4gICAgICBjb25zdCBjdXJyZW50SHJlZnM6IHN0cmluZ1tdID0gY3VycmVudFN0eWxlVGFncy5tYXAoXG4gICAgICAgICh0YWcpID0+IHRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykhXG4gICAgICApXG5cbiAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICBsZXQgcmVmZXJlbmNlTm9kZTogRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnbm9zY3JpcHRbZGF0YS1uLWNzc10nXG4gICAgICApXG4gICAgICBpZiAoXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgcmVmZXJlbmNlTm9kZVxuICAgICAgKSB7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiB9OiB7IGhyZWY6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0VGFnOiBFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYFxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICB0YXJnZXRUYWdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUhLnBhcmVudE5vZGUhLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgdGFyZ2V0VGFnLFxuICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlIS5uZXh0U2libGluZ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZ1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgbG9vc2VUb0FycmF5PEhUTUxMaW5rRWxlbWVudD4oXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJylcbiAgICAgICkuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwucGFyZW50Tm9kZSEucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChpbnB1dC5zY3JvbGwpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW5wdXQuc2Nyb2xsXG4gICAgICBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHgsIHkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpOiB2b2lkIHtcbiAgICByZXNvbHZlUHJvbWlzZSgpXG4gIH1cblxuICBvblN0YXJ0KClcblxuICBjb25zdCBlbGVtOiBKU1guRWxlbWVudCA9IChcbiAgICA8PlxuICAgICAgPEhlYWQgY2FsbGJhY2s9e29uSGVhZENvbW1pdH0gLz5cbiAgICAgIDxBcHBDb250YWluZXI+XG4gICAgICAgIHtyZW5kZXJBcHAoQXBwLCBhcHBQcm9wcyl9XG4gICAgICAgIDxQb3J0YWwgdHlwZT1cIm5leHQtcm91dGUtYW5ub3VuY2VyXCI+XG4gICAgICAgICAgPFJvdXRlQW5ub3VuY2VyIC8+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICAgPC9BcHBDb250YWluZXI+XG4gICAgPC8+XG4gIClcblxuICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQhLCAoY2FsbGJhY2spID0+IChcbiAgICA8Um9vdCBjYWxsYmFja3M9e1tjYWxsYmFjaywgb25Sb290Q29tbWl0XX0+XG4gICAgICB7cHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gKFxuICAgICAgICA8UmVhY3QuU3RyaWN0TW9kZT57ZWxlbX08L1JlYWN0LlN0cmljdE1vZGU+XG4gICAgICApIDogKFxuICAgICAgICBlbGVtXG4gICAgICApfVxuICAgIDwvUm9vdD5cbiAgKSlcblxuICByZXR1cm4gcmVuZGVyUHJvbWlzZVxufVxuXG5hc3luYyBmdW5jdGlvbiByZW5kZXIocmVuZGVyaW5nUHJvcHM6IFJlbmRlclJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBpZiBhbiBlcnJvciBvY2N1cnMgaW4gYSBzZXJ2ZXItc2lkZSBwYWdlIChlLmcuIGluIGdldEluaXRpYWxQcm9wcyksXG4gIC8vIHNraXAgcmUtcmVuZGVyaW5nIHRoZSBlcnJvciBwYWdlIGNsaWVudC1zaWRlIGFzIGRhdGEtZmV0Y2hpbmcgb3BlcmF0aW9uc1xuICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGRvbmUgb24gdGhlIHNlcnZlciBhbmQgTkVYVF9EQVRBIGNvbnRhaW5zIHRoZSBjb3JyZWN0XG4gIC8vIGRhdGEgZm9yIHN0cmFpZ2h0LWZvcndhcmQgaHlkcmF0aW9uIG9mIHRoZSBlcnJvciBwYWdlXG4gIGlmIChcbiAgICByZW5kZXJpbmdQcm9wcy5lcnIgJiZcbiAgICAvLyByZW5kZXJpbmdQcm9wcy5Db21wb25lbnQgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIGEgdG9wL21vZHVsZS1sZXZlbCBlcnJvclxuICAgICh0eXBlb2YgcmVuZGVyaW5nUHJvcHMuQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgIXJlbmRlcmluZ1Byb3BzLmlzSHlkcmF0ZVBhc3MpXG4gICkge1xuICAgIGF3YWl0IHJlbmRlckVycm9yKHJlbmRlcmluZ1Byb3BzKVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1JlbmRlcihyZW5kZXJpbmdQcm9wcylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgcmVuZGVyRXJyID0gZ2V0UHJvcGVyRXJyb3IoZXJyKVxuICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICBpZiAoKHJlbmRlckVyciBhcyBFcnJvciAmIHsgY2FuY2VsbGVkPzogYm9vbGVhbiB9KS5jYW5jZWxsZWQpIHtcbiAgICAgIHRocm93IHJlbmRlckVyclxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgcmVuZGVyRXJyXG4gICAgICB9KVxuICAgIH1cbiAgICBhd2FpdCByZW5kZXJFcnJvcih7IC4uLnJlbmRlcmluZ1Byb3BzLCBlcnI6IHJlbmRlckVyciB9KVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoeWRyYXRlKG9wdHM/OiB7IGJlZm9yZVJlbmRlcj86ICgpID0+IFByb21pc2U8dm9pZD4gfSkge1xuICBsZXQgaW5pdGlhbEVyciA9IGluaXRpYWxEYXRhLmVyclxuXG4gIHRyeSB7XG4gICAgY29uc3QgYXBwRW50cnlwb2ludCA9IGF3YWl0IHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoJy9fYXBwJylcbiAgICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCwgZXhwb3J0czogbW9kIH0gPSBhcHBFbnRyeXBvaW50XG4gICAgQ2FjaGVkQXBwID0gYXBwIGFzIEFwcENvbXBvbmVudFxuICAgIGlmIChtb2QgJiYgbW9kLnJlcG9ydFdlYlZpdGFscykge1xuICAgICAgb25QZXJmRW50cnkgPSAoe1xuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVudHJ5VHlwZSxcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgYXR0cmlidXRpb24sXG4gICAgICB9OiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgIGNvbnN0IHVuaXF1ZUlEOiBzdHJpbmcgPSBgJHtEYXRlLm5vdygpfS0ke1xuICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5ZTEyIC0gMSkpICsgMWUxMlxuICAgICAgICB9YFxuICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2ViVml0YWxzOiBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICBsYWJlbDpcbiAgICAgICAgICAgIGVudHJ5VHlwZSA9PT0gJ21hcmsnIHx8IGVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnXG4gICAgICAgICAgICAgID8gJ2N1c3RvbSdcbiAgICAgICAgICAgICAgOiAnd2ViLXZpdGFsJyxcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRpb24pIHtcbiAgICAgICAgICB3ZWJWaXRhbHMuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvblxuICAgICAgICB9XG4gICAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID1cbiAgICAgIC8vIFRoZSBkZXYgc2VydmVyIGZhaWxzIHRvIHNlcnZlIHNjcmlwdCBhc3NldHMgd2hlbiB0aGVyZSdzIGEgaHlkcmF0aW9uXG4gICAgICAvLyBlcnJvciwgc28gd2UgbmVlZCB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSBlbnRyeXBvaW50LlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbERhdGEuZXJyXG4gICAgICAgID8geyBlcnJvcjogaW5pdGlhbERhdGEuZXJyIH1cbiAgICAgICAgOiBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpXG4gICAgaWYgKCdlcnJvcicgaW4gcGFnZUVudHJ5cG9pbnQpIHtcbiAgICAgIHRocm93IHBhZ2VFbnRyeXBvaW50LmVycm9yXG4gICAgfVxuICAgIENhY2hlZENvbXBvbmVudCA9IHBhZ2VFbnRyeXBvaW50LmNvbXBvbmVudFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPVxuICAgICAgICByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKSBhcyB0eXBlb2YgaW1wb3J0KCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKVxuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke2luaXRpYWxEYXRhLnBhZ2V9XCJgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICBpbml0aWFsRXJyID0gZ2V0UHJvcGVyRXJyb3IoZXJyb3IpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCBnZXRTZXJ2ZXJFcnJvciA9IChcbiAgICAgIHJlcXVpcmUoJy4uL3NlcnZlci9kZXYvbm9kZS1zdGFjay1mcmFtZXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zZXJ2ZXIvZGV2L25vZGUtc3RhY2stZnJhbWVzJylcbiAgICApLmdldFNlcnZlckVycm9yXG4gICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgLy8gdGhhdCB0aGUgb3ZlcmxheSBpcyByZW5kZXJlZC5cbiAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgaWYgKGluaXRpYWxFcnIgPT09IGluaXRpYWxEYXRhLmVycikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBsZXQgZXJyb3JcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gd2lsbCBzZXQgdGhlIGBzdGFja2Agd2hlbiB0aHJvd24sIGFuZCB3ZSB3YW50IHRvIGVuc3VyZSBvdXJzIGlzXG4gICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIhLm1lc3NhZ2UpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlIGFzIEVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIhLm5hbWVcbiAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIhLnN0YWNrXG4gICAgICAgICAgY29uc3QgZXJyU291cmNlID0gaW5pdGlhbEVyci5zb3VyY2UhXG5cbiAgICAgICAgICAvLyBJbiBkZXZlbG9wbWVudCwgZXJyb3IgdGhlIG5hdmlnYXRpb24gQVBJIHVzYWdlIGluIHJ1bnRpbWUsXG4gICAgICAgICAgLy8gc2luY2UgaXQncyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHBhZ2VzIHJvdXRlciBhcyBpdCBkb2Vzbid0IGNvbnRhaW4gZXJyb3IgYm91bmRhcnkgbGlrZSBhcHAgcm91dGVyLlxuICAgICAgICAgIGlmIChpc05leHRSb3V0ZXJFcnJvcihpbml0aWFsRXJyKSkge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9XG4gICAgICAgICAgICAgICdOZXh0LmpzIG5hdmlnYXRpb24gQVBJIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gUGFnZXMgUm91dGVyLidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBnZXRTZXJ2ZXJFcnJvcihlcnJvciwgZXJyU291cmNlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gV2UgcmVwbGFjZWQgdGhlIHNlcnZlci1zaWRlIGVycm9yIHdpdGggYSBjbGllbnQtc2lkZSBlcnJvciwgYW5kIHNob3VsZFxuICAgICAgLy8gbm8gbG9uZ2VyIHJld3JpdGUgdGhlIHN0YWNrIHRyYWNlIHRvIGEgTm9kZSBlcnJvci5cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgYXdhaXQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoaW5pdGlhbERhdGEuZHluYW1pY0lkcylcbiAgfVxuXG4gIHJvdXRlciA9IGNyZWF0ZVJvdXRlcihpbml0aWFsRGF0YS5wYWdlLCBpbml0aWFsRGF0YS5xdWVyeSwgYXNQYXRoLCB7XG4gICAgaW5pdGlhbFByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICBwYWdlTG9hZGVyLFxuICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgIHdyYXBBcHAsXG4gICAgZXJyOiBpbml0aWFsRXJyLFxuICAgIGlzRmFsbGJhY2s6IEJvb2xlYW4oaW5pdGlhbERhdGEuaXNGYWxsYmFjayksXG4gICAgc3Vic2NyaXB0aW9uOiAoaW5mbywgQXBwLCBzY3JvbGwpID0+XG4gICAgICByZW5kZXIoXG4gICAgICAgIE9iamVjdC5hc3NpZ248XG4gICAgICAgICAge30sXG4gICAgICAgICAgT21pdDxSZW5kZXJSb3V0ZUluZm8sICdBcHAnIHwgJ3Njcm9sbCc+LFxuICAgICAgICAgIFBpY2s8UmVuZGVyUm91dGVJbmZvLCAnQXBwJyB8ICdzY3JvbGwnPlxuICAgICAgICA+KHt9LCBpbmZvLCB7XG4gICAgICAgICAgQXBwLFxuICAgICAgICAgIHNjcm9sbCxcbiAgICAgICAgfSkgYXMgUmVuZGVyUm91dGVJbmZvXG4gICAgICApLFxuICAgIGxvY2FsZTogaW5pdGlhbERhdGEubG9jYWxlLFxuICAgIGxvY2FsZXM6IGluaXRpYWxEYXRhLmxvY2FsZXMsXG4gICAgZGVmYXVsdExvY2FsZSxcbiAgICBkb21haW5Mb2NhbGVzOiBpbml0aWFsRGF0YS5kb21haW5Mb2NhbGVzLFxuICAgIGlzUHJldmlldzogaW5pdGlhbERhdGEuaXNQcmV2aWV3LFxuICB9KVxuXG4gIGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSA9IGF3YWl0IHJvdXRlci5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZVxuXG4gIGNvbnN0IHJlbmRlckN0eDogUmVuZGVyUm91dGVJbmZvID0ge1xuICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgIGluaXRpYWw6IHRydWUsXG4gICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgcHJvcHM6IGluaXRpYWxEYXRhLnByb3BzLFxuICAgIGVycjogaW5pdGlhbEVycixcbiAgICBpc0h5ZHJhdGVQYXNzOiB0cnVlLFxuICB9XG5cbiAgaWYgKG9wdHM/LmJlZm9yZVJlbmRlcikge1xuICAgIGF3YWl0IG9wdHMuYmVmb3JlUmVuZGVyKClcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJDdHgpXG59XG4iXSwibmFtZXMiOlsiZW1pdHRlciIsImh5ZHJhdGUiLCJpbml0aWFsaXplIiwicm91dGVyIiwidmVyc2lvbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVkVSU0lPTiIsIm1pdHQiLCJsb29zZVRvQXJyYXkiLCJpbnB1dCIsInNsaWNlIiwiY2FsbCIsImluaXRpYWxEYXRhIiwiZGVmYXVsdExvY2FsZSIsInVuZGVmaW5lZCIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJhcHBFbGVtZW50IiwiaGVhZE1hbmFnZXIiLCJpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUiLCJsYXN0QXBwUHJvcHMiLCJsYXN0UmVuZGVyUmVqZWN0IiwiZGV2Q2xpZW50IiwiQ2FjaGVkQXBwIiwib25QZXJmRW50cnkiLCJDYWNoZWRDb21wb25lbnQiLCJDb250YWluZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZENhdGNoIiwiY29tcG9uZW50RXJyIiwiaW5mbyIsInByb3BzIiwiZm4iLCJjb21wb25lbnREaWRNb3VudCIsInNjcm9sbFRvSGFzaCIsImlzU3NyIiwiaXNGYWxsYmFjayIsIm5leHRFeHBvcnQiLCJpc0R5bmFtaWNSb3V0ZSIsInBhdGhuYW1lIiwibG9jYXRpb24iLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJfaCIsInNoYWxsb3ciLCJjYXRjaCIsImVyciIsImNhbmNlbGxlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImhhc2giLCJzdWJzdHJpbmciLCJlbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJyZW5kZXIiLCJOT0RFX0VOViIsImNoaWxkcmVuIiwiUGFnZXNEZXZPdmVybGF5QnJpZGdlIiwicmVxdWlyZSIsIm9wdHMiLCJ0cmFjZXIiLCJvblNwYW5FbmQiLCJkZWZhdWx0IiwiSlNPTiIsInBhcnNlIiwidGV4dENvbnRlbnQiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwicHJlZml4IiwiYXNzZXRQcmVmaXgiLCJzZWxmIiwiX19uZXh0X3NldF9wdWJsaWNfcGF0aF9fIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicGFyc2VSZWxhdGl2ZVVybCIsImZvcm1hdFVybCIsImxvY2FsZXMiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImxvY2FsZSIsImRldGVjdGVkRG9tYWluIiwiX19ORVhUX0kxOE5fRE9NQUlOUyIsImhvc3RuYW1lIiwic2NyaXB0TG9hZGVyIiwiaW5pdFNjcmlwdExvYWRlciIsIlBhZ2VMb2FkZXIiLCJidWlsZElkIiwicmVnaXN0ZXIiLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwicHVzaCIsImluaXRIZWFkTWFuYWdlciIsImdldElzU3NyIiwicmVuZGVyQXBwIiwiQXBwIiwiYXBwUHJvcHMiLCJBcHBDb250YWluZXIiLCJhZGFwdGVkRm9yQXBwUm91dGVyIiwidXNlTWVtbyIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJlcnJvciIsInJlbmRlckVycm9yIiwiY29uc29sZSIsIkFwcFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsImFkYXB0Rm9yU2VhcmNoUGFyYW1zIiwiUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyIiwiaXNBdXRvRXhwb3J0IiwiYXV0b0V4cG9ydCIsIlBhdGhQYXJhbXNDb250ZXh0IiwiYWRhcHRGb3JQYXRoUGFyYW1zIiwiUm91dGVyQ29udGV4dCIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid3JhcEFwcCIsIndyYXBwZWRBcHBQcm9wcyIsInJlbmRlckVycm9yUHJvcHMiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImRvUmVuZGVyIiwic3R5bGVTaGVldHMiLCJsb2FkUGFnZSIsInRoZW4iLCJwYWdlIiwiRXJyb3JDb21wb25lbnQiLCJlcnJvck1vZHVsZSIsImFwcE1vZHVsZSIsIm0iLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwiSGVhZCIsImNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwicGVyZm9ybWFuY2VNYXJrcyIsIm5hdmlnYXRpb25TdGFydCIsImJlZm9yZVJlbmRlciIsImFmdGVyUmVuZGVyIiwiYWZ0ZXJIeWRyYXRlIiwicm91dGVDaGFuZ2UiLCJwZXJmb3JtYW5jZU1lYXN1cmVzIiwiaHlkcmF0aW9uIiwiYmVmb3JlSHlkcmF0aW9uIiwicm91dGVDaGFuZ2VUb1JlbmRlciIsInJlYWN0Um9vdCIsInNob3VsZEh5ZHJhdGUiLCJjbGVhck1hcmtzIiwiZm9yRWFjaCIsIm1hcmsiLCJwZXJmb3JtYW5jZSIsIm1hcmtIeWRyYXRlQ29tcGxldGUiLCJTVCIsImhhc0JlZm9yZVJlbmRlck1hcmsiLCJnZXRFbnRyaWVzQnlOYW1lIiwibGVuZ3RoIiwiYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSIsIm1lYXN1cmUiLCJoeWRyYXRpb25NZWFzdXJlIiwic3RhcnRTcGFuIiwic3RhcnRUaW1lIiwidGltZU9yaWdpbiIsImF0dHJpYnV0ZXMiLCJlbmQiLCJkdXJhdGlvbiIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsIm5hbWUiLCJjbGVhck1lYXN1cmVzIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiZG9tRWwiLCJyZWFjdEVsIiwiUmVhY3RET00iLCJoeWRyYXRlUm9vdCIsIm9uUmVjb3ZlcmFibGVFcnJvciIsInN0YXJ0VHJhbnNpdGlvbiIsIlJvb3QiLCJjYWxsYmFja3MiLCJfX05FWFRfVEVTVF9NT0RFIiwidXNlRWZmZWN0IiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0FUIiwibm93IiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiY2FuY2VsZWQiLCJyZXNvbHZlUHJvbWlzZSIsInJlbmRlclByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9uSGVhZENvbW1pdCIsIlRVUkJPUEFDSyIsImRlc2lyZWRIcmVmcyIsInMiLCJpZHgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZWZlcmVuY2VOb2RlIiwidGFyZ2V0VGFnIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwicmVtb3ZlQ2hpbGQiLCJzY3JvbGwiLCJ4IiwieSIsImRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24iLCJzY3JvbGxUbyIsIm9uUm9vdENvbW1pdCIsImVsZW0iLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwicmVuZGVyaW5nUHJvcHMiLCJpc0h5ZHJhdGVQYXNzIiwicmVuZGVyRXJyIiwiZ2V0UHJvcGVyRXJyb3IiLCJpbml0aWFsRXJyIiwiYXBwRW50cnlwb2ludCIsIndoZW5FbnRyeXBvaW50IiwiY29tcG9uZW50IiwiYXBwIiwiZXhwb3J0cyIsIm1vZCIsInJlcG9ydFdlYlZpdGFscyIsImlkIiwiZW50cnlUeXBlIiwiZW50cmllcyIsImF0dHJpYnV0aW9uIiwidW5pcXVlSUQiLCJEYXRlIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0U2VydmVyRXJyb3IiLCJtZXNzYWdlIiwiZSIsInN0YWNrIiwiZXJyU291cmNlIiwic291cmNlIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiZHluYW1pY0lkcyIsImNyZWF0ZVJvdXRlciIsImluaXRpYWxQcm9wcyIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJPYmplY3QiLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3IiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJyZW5kZXJDdHgiLCJpbml0aWFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createKey: function() {\n        return createKey;\n    },\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"(pages-dir-browser)/./node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"(pages-dir-browser)/./node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"(pages-dir-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"(pages-dir-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"(pages-dir-browser)/./node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ./utils/disable-smooth-scroll */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _constants = __webpack_require__(/*! ../../../lib/constants */ \"(pages-dir-browser)/./node_modules/next/dist/lib/constants.js\");\nconst _deploymentid = __webpack_require__(/*! ../deployment-id */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/deployment-id.js\");\nlet resolveRewrites;\nif (false) {}\nfunction buildCancellationError() {\n    return Object.assign(Object.defineProperty(new Error('Route Cancelled'), \"__NEXT_ERROR_CODE\", {\n        value: \"E315\",\n        enumerable: false,\n        configurable: true\n    }), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/') || false) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(([pages, { __rewrites: rewrites }])=>{\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        });\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: `${pathname}${src.query}${src.hash}`\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            });\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: `${pathname}${src.query}${src.hash}`,\n                newUrl: `${pathname}${src.query}${src.hash}`\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    const data = await options.fetchData();\n    const effect = await getMiddlewareData(data.dataHref, data.response, options);\n    return {\n        dataHref: data.dataHref,\n        json: data.json,\n        response: data.response,\n        text: data.text,\n        cacheKey: data.cacheKey,\n        effect\n    };\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wont send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData({ dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache }) {\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    const getData = (params)=>fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: 'prefetch'\n            } : {}, isPrefetch && hasMiddleware ? {\n                'x-middleware-prefetch': '1'\n            } : {}, deploymentId ? {\n                'x-deployment-id': deploymentId\n            } : {}),\n            method: params?.method ?? 'GET'\n        }).then((response)=>{\n            if (response.ok && params?.method === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        if (tryToParseAsJSON(text)?.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = Object.defineProperty(new Error(`Failed to load static props`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E124\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== 'production' || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === 'Failed to fetch' || // firefox\n            err.message === 'NetworkError when attempting to fetch resource.' || // safari\n            err.message === 'Load failed') {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n                // only update cache if not marked as no-cache\n                inflightCache[cacheKey] = Promise.resolve(data);\n            }\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation({ url, router }) {\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw Object.defineProperty(new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E282\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = ({ route, router })=>{\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = Object.defineProperty(new Error(`Abort fetching component for route: \"${route}\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E483\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    static{\n        this.events = (0, _mitt.default)();\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    // if middleware matches we leave resolving to the change function\n                    // as the server needs to resolve for correct priority\n                    ;\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (false) {}\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (true) {\n            if (!this._bfl_s && !this._bfl_d) {\n                const { BloomFilter } = __webpack_require__(/*! ../../lib/bloom-filter */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/bloom-filter.js\");\n                let staticFilterData;\n                let dynamicFilterData;\n                try {\n                    ;\n                    ({ __routerFilterStatic: staticFilterData, __routerFilterDynamic: dynamicFilterData } = await (0, _routeloader.getClientBuildManifest)());\n                } catch (err) {\n                    // failed to load build manifest hard navigate\n                    // to be safe\n                    console.error(err);\n                    if (skipNavigate) {\n                        return true;\n                    }\n                    handleHardNavigation({\n                        url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routerFilterSValue = {\"numItems\":13,\"errorRate\":0.0001,\"numBits\":250,\"numHashes\":14,\"bitArray\":[1,1,0,1,0,0,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0]};\n                if (!staticFilterData && routerFilterSValue) {\n                    staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n                }\n                const routerFilterDValue = {\"numItems\":1,\"errorRate\":0.0001,\"numBits\":20,\"numHashes\":14,\"bitArray\":[0,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1]};\n                if (!dynamicFilterData && routerFilterDValue) {\n                    dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n                }\n                if (staticFilterData?.numHashes) {\n                    this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                    this._bfl_s.import(staticFilterData);\n                }\n                if (dynamicFilterData?.numHashes) {\n                    this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                    this._bfl_d.import(dynamicFilterData);\n                }\n            }\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            const pathsToCheck = [\n                {\n                    as\n                },\n                {\n                    as: resolvedAs\n                }\n            ];\n            for (const { as: curAs, allowMatchCurrent } of pathsToCheck){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {\n                        matchesBflStatic = matchesBflStatic || !!this._bfl_s?.contains(asNoSlash) || !!this._bfl_s?.contains(asNoSlashLocale);\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split('/');\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                const currentPart = curAsParts.slice(0, i).join('/');\n                                if (currentPart && this._bfl_d?.contains(currentPart)) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (false) {}\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            ;\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if (this.components[pathname]?.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== '/_error') {\n            ;\n            options._shouldResolveHref = true;\n            if (false) {} else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (true) {\n                throw Object.defineProperty(new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E380\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (true) {\n                        console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                    }\n                    throw Object.defineProperty(new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E344\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit('routeChangeStart', as, routeProps);\n        }\n        const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';\n        try {\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if ('route' in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (false) {}\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if ('type' in routeInfo) {\n                if (routeInfo.type === 'redirect-internal') {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if ('type' in routeInfo) {\n                        throw Object.defineProperty(new Error(`Unexpected middleware effect on /404`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E158\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === '/_error' && self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 && routeInfo.props?.pageProps) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === (routeInfo.route ?? route);\n            const shouldScroll = options.scroll ?? (!isQueryUpdating && !isValidShallowRoute);\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll ?? resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if ('type' in routeInfo) {\n                    throw Object.defineProperty(new Error(`Unexpected middleware effect on ${this.pathname}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E225\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (this.pathname === '/_error' && self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 && routeInfo.props?.pageProps) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (false) {}\n                if (!isQueryUpdating) {\n                    Router.events.emit('routeChangeComplete', as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options = {}) {\n        if (true) {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        console.error(err);\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent('/_error');\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ''), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            }), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo({ route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound }) {\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && \"development\" !== 'development' ? 0 : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? '/404' : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? '/404' : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === '/_error' || pathname === '/404')) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if (data?.effect?.type === 'redirect-internal' || data?.effect?.type === 'redirect-external') {\n                return data.effect;\n            }\n            if (data?.effect?.type === 'rewrite') {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (true) {\n                const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${pathname}\"`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E286\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            const wasBailedPrefetch = data?.response?.headers.get('x-middleware-skip');\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && data?.dataHref) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if (data?.json && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = data?.dataHref ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && \"development\" !== 'development' && 0) {}\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2);\n        const [newUrlNoHash, newHash] = as.split('#', 2);\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#', 2);\n        (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === '' || hash === 'top') {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath = url, options = {}) {\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (true) {\n            return;\n        }\n        if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (false) {}\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (false) {}\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data =  false ? 0 : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if (data?.effect.type === 'rewrite') {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if (data?.effect.type === 'redirect-external') {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: data?.json ? data?.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = Object.defineProperty(new Error('Loading initial props cancelled'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E405\",\n                    enumerable: false,\n                    configurable: true\n                });\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n} //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTRtQmdCQSxTQUFTO2VBQVRBOztJQWlEaEIsT0FpNERDO2VBajREb0JDOztJQTVqQkNDLGlCQUFpQjtlQUFqQkE7Ozs7O2lEQXhGYzt5Q0FLN0I7b0NBQ2dDOytFQUNDO2lEQUNKO2lEQUNBOzJFQUNuQjttQ0FDa0Q7dUNBQ3BDOzhDQUNFOzBDQUNEO3dDQUNGO3VDQUNPO2dEQUNGO3VDQUNUO3VDQUNBOzBDQUNHOzRDQUNFO3lDQUNIO3lDQUNBO3lDQUNBO3dDQUNEO2lEQUNTO29EQUNHOzJDQUNIO3dDQUNUO21DQUNMO2tDQUNEOzJDQUNTO2lEQUMyQjt1Q0FFckI7MENBQ0o7QUFFaEMsSUFBSUM7QUFDSixJQUFJQyxLQUErQixFQUFFLEVBSXBDO0FBZ0NELFNBQVNLO0lBQ1AsT0FBT0MsT0FBT0MsTUFBTSxDQUFDLHFCQUE0QixDQUE1QixJQUFJQyxNQUFNLG9CQUFWO2VBQUE7b0JBQUE7c0JBQUE7SUFBMkIsSUFBRztRQUNqREMsV0FBVztJQUNiO0FBQ0Y7QUFTTyxlQUFlWCxrQkFDcEJZLE9BQWtDO0lBRWxDLE1BQU1DLFdBQVcsTUFBTUMsUUFBUUMsT0FBTyxDQUNwQ0gsUUFBUUksTUFBTSxDQUFDQyxVQUFVLENBQUNDLGFBQWE7SUFFekMsSUFBSSxDQUFDTCxVQUFVLE9BQU87SUFFdEIsTUFBTSxFQUFFTSxVQUFVQyxVQUFVLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsV0FBQUEsU0FBQUEsRUFBVVQsUUFBUVUsTUFBTTtJQUN6RCw2RkFBNkY7SUFDN0YsTUFBTUMsWUFBWUMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWUosY0FDMUJLLENBQUFBLEdBQUFBLGdCQUFBQSxjQUFBQSxFQUFlTCxjQUNmQTtJQUNKLE1BQU1NLDBCQUEwQkMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FB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QUM1QjtJQUVBLElBQUkyRSxRQUF3QjtRQUMxQixPQUFPLElBQUksQ0FBQ2lHLEtBQUssQ0FBQ2pHLEtBQUs7SUFDekI7SUFFQSxJQUFJeEUsU0FBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUN5SyxLQUFLLENBQUN6SyxNQUFNO0lBQzFCO0lBRUEsSUFBSU8sU0FBNkI7UUFDL0IsT0FBTyxJQUFJLENBQUNrSyxLQUFLLENBQUNsSyxNQUFNO0lBQzFCO0lBRUEsSUFBSXlKLGFBQXNCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDUyxLQUFLLENBQUNULFVBQVU7SUFDOUI7SUFFQSxJQUFJRSxZQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQ08sS0FBSyxDQUFDUCxTQUFTO0lBQzdCO0FBQ0YiLCJzb3VyY2VzIjpbIi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBEb21haW5Mb2NhbGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgdHlwZSB7IFJvdXRlckV2ZW50IH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JvdXRlcidcbmltcG9ydCB0eXBlIHsgU3R5bGVTaGVldFR1cGxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSBQYWdlTG9hZGVyIGZyb20gJy4uLy4uLy4uL2NsaWVudC9wYWdlLWxvYWRlcidcbmltcG9ydCB0eXBlIHsgQXBwQ29udGV4dFR5cGUsIE5leHRQYWdlQ29udGV4dCwgTkVYVF9EQVRBIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyByZW1vdmVUcmFpbGluZ1NsYXNoIH0gZnJvbSAnLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQge1xuICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0LFxuICBpc0Fzc2V0RXJyb3IsXG4gIG1hcmtBc3NldEVycm9yLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHsgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9zY3JpcHQnXG5pbXBvcnQgaXNFcnJvciwgeyBnZXRQcm9wZXJFcnJvciB9IGZyb20gJy4uLy4uLy4uL2xpYi9pcy1lcnJvcidcbmltcG9ydCB7IGRlbm9ybWFsaXplUGFnZVBhdGggfSBmcm9tICcuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoJ1xuaW1wb3J0IHsgbm9ybWFsaXplTG9jYWxlUGF0aCB9IGZyb20gJy4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJ1xuaW1wb3J0IG1pdHQgZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7IGdldExvY2F0aW9uT3JpZ2luLCBnZXRVUkwsIGxvYWRHZXRJbml0aWFsUHJvcHMsIFNUIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuaW1wb3J0IHsgZm9ybWF0V2l0aFZhbGlkYXRpb24gfSBmcm9tICcuL3V0aWxzL2Zvcm1hdC11cmwnXG5pbXBvcnQgeyBkZXRlY3REb21haW5Mb2NhbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvZGV0ZWN0LWRvbWFpbi1sb2NhbGUnXG5pbXBvcnQgeyBwYXJzZVBhdGggfSBmcm9tICcuL3V0aWxzL3BhcnNlLXBhdGgnXG5pbXBvcnQgeyBhZGRMb2NhbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZSdcbmltcG9ydCB7IHJlbW92ZUxvY2FsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yZW1vdmUtbG9jYWxlJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBoYXNCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgcmVzb2x2ZUhyZWYgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcmVzb2x2ZS1ocmVmJ1xuaW1wb3J0IHsgaXNBUElSb3V0ZSB9IGZyb20gJy4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGUnXG5pbXBvcnQgeyBnZXROZXh0UGF0aG5hbWVJbmZvIH0gZnJvbSAnLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvJ1xuaW1wb3J0IHsgZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyB9IGZyb20gJy4vdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mbydcbmltcG9ydCB7IGNvbXBhcmVSb3V0ZXJTdGF0ZXMgfSBmcm9tICcuL3V0aWxzL2NvbXBhcmUtc3RhdGVzJ1xuaW1wb3J0IHsgaXNMb2NhbFVSTCB9IGZyb20gJy4vdXRpbHMvaXMtbG9jYWwtdXJsJ1xuaW1wb3J0IHsgaXNCb3QgfSBmcm9tICcuL3V0aWxzL2lzLWJvdCdcbmltcG9ydCB7IG9taXQgfSBmcm9tICcuL3V0aWxzL29taXQnXG5pbXBvcnQgeyBpbnRlcnBvbGF0ZUFzIH0gZnJvbSAnLi91dGlscy9pbnRlcnBvbGF0ZS1hcydcbmltcG9ydCB7IGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24gfSBmcm9tICcuL3V0aWxzL2Rpc2FibGUtc21vb3RoLXNjcm9sbCdcbmltcG9ydCB0eXBlIHsgUGFyYW1zIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL3JlcXVlc3QvcGFyYW1zJ1xuaW1wb3J0IHsgTUFUQ0hFRF9QQVRIX0hFQURFUiB9IGZyb20gJy4uLy4uLy4uL2xpYi9jb25zdGFudHMnXG5pbXBvcnQgeyBnZXREZXBsb3ltZW50SWQgfSBmcm9tICcuLi9kZXBsb3ltZW50LWlkJ1xuXG5sZXQgcmVzb2x2ZVJld3JpdGVzOiB0eXBlb2YgaW1wb3J0KCcuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXMnKS5kZWZhdWx0XG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICByZXNvbHZlUmV3cml0ZXMgPSAoXG4gICAgcmVxdWlyZSgnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJykgYXMgdHlwZW9mIGltcG9ydCgnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJylcbiAgKS5kZWZhdWx0XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgLyogcHJvZCAqL1xuICAgIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICB9XG59XG5cbmludGVyZmFjZSBSb3V0ZVByb3BlcnRpZXMge1xuICBzaGFsbG93OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBUcmFuc2l0aW9uT3B0aW9ucyB7XG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gIHNjcm9sbD86IGJvb2xlYW5cbiAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgTmV4dEhpc3RvcnlTdGF0ZSB7XG4gIHVybDogc3RyaW5nXG4gIGFzOiBzdHJpbmdcbiAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbn1cblxuZXhwb3J0IHR5cGUgSGlzdG9yeVN0YXRlID1cbiAgfCBudWxsXG4gIHwgeyBfX05BOiB0cnVlOyBfX04/OiBmYWxzZSB9XG4gIHwgeyBfX046IGZhbHNlOyBfX05BPzogZmFsc2UgfVxuICB8ICh7IF9fTkE/OiBmYWxzZTsgX19OOiB0cnVlOyBrZXk6IHN0cmluZyB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgIGNhbmNlbGxlZDogdHJ1ZSxcbiAgfSlcbn1cblxuaW50ZXJmYWNlIE1pZGRsZXdhcmVFZmZlY3RQYXJhbXM8VCBleHRlbmRzIEZldGNoRGF0YU91dHB1dD4ge1xuICBmZXRjaERhdGE/OiAoKSA9PiBQcm9taXNlPFQ+XG4gIGxvY2FsZT86IHN0cmluZ1xuICBhc1BhdGg6IHN0cmluZ1xuICByb3V0ZXI6IFJvdXRlclxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWF0Y2hlc01pZGRsZXdhcmU8VCBleHRlbmRzIEZldGNoRGF0YU91dHB1dD4oXG4gIG9wdGlvbnM6IE1pZGRsZXdhcmVFZmZlY3RQYXJhbXM8VD5cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBtYXRjaGVycyA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShcbiAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKVxuICApXG4gIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHBhcnNlUGF0aChvcHRpb25zLmFzUGF0aClcbiAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gIGNvbnN0IGNsZWFuZWRBcyA9IGhhc0Jhc2VQYXRoKGFzUGF0aG5hbWUpXG4gICAgPyByZW1vdmVCYXNlUGF0aChhc1BhdGhuYW1lKVxuICAgIDogYXNQYXRobmFtZVxuICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9IGFkZEJhc2VQYXRoKFxuICAgIGFkZExvY2FsZShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKVxuICApXG5cbiAgLy8gQ2hlY2sgb25seSBwYXRoIG1hdGNoIG9uIGNsaWVudC4gTWF0Y2hpbmcgXCJoYXNcIiBzaG91bGQgYmUgZG9uZSBvbiBzZXJ2ZXJcbiAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG0pID0+XG4gICAgbmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSlcbiAgKVxufVxuXG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmw6IHN0cmluZykge1xuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG5cbiAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsXG59XG5cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXI6IE5leHRSb3V0ZXIsIHVybDogVXJsLCBhcz86IFVybCkge1xuICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gcmVzb2x2ZUhyZWYocm91dGVyLCB1cmwsIHRydWUpXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKVxuICBjb25zdCBhc1dhc0Fic29sdXRlID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKVxuXG4gIHJlc29sdmVkSHJlZiA9IHN0cmlwT3JpZ2luKHJlc29sdmVkSHJlZilcbiAgcmVzb2x2ZWRBcyA9IHJlc29sdmVkQXMgPyBzdHJpcE9yaWdpbihyZXNvbHZlZEFzKSA6IHJlc29sdmVkQXNcblxuICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6IGFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZilcbiAgY29uc3QgcHJlcGFyZWRBcyA9IGFzXG4gICAgPyBzdHJpcE9yaWdpbihyZXNvbHZlSHJlZihyb3V0ZXIsIGFzKSlcbiAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmXG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgIGFzOiBhc1dhc0Fic29sdXRlID8gcHJlcGFyZWRBcyA6IGFkZEJhc2VQYXRoKHByZXBhcmVkQXMpLFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWU6IHN0cmluZywgcGFnZXM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKGRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKVxuICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgIHJldHVybiBwYXRobmFtZVxuICB9XG5cbiAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgIHBhZ2VzLnNvbWUoKHBhZ2UpID0+IHtcbiAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYWdlKSAmJiBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBwYWdlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbn1cblxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGE8VCBleHRlbmRzIEZldGNoRGF0YU91dHB1dD4oXG4gIHNvdXJjZTogc3RyaW5nLFxuICByZXNwb25zZTogUmVzcG9uc2UsXG4gIG9wdGlvbnM6IE1pZGRsZXdhcmVFZmZlY3RQYXJhbXM8VD5cbikge1xuICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICBpMThuOiB7IGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXMgfSxcbiAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSCksXG4gIH1cbiAgY29uc3QgcmV3cml0ZUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZXdyaXRlJylcblxuICBsZXQgcmV3cml0ZVRhcmdldCA9XG4gICAgcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtbWF0Y2hlZC1wYXRoJylcblxuICBjb25zdCBtYXRjaGVkUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE1BVENIRURfUEFUSF9IRUFERVIpXG5cbiAgaWYgKFxuICAgIG1hdGNoZWRQYXRoICYmXG4gICAgIXJld3JpdGVUYXJnZXQgJiZcbiAgICAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJ19fbmV4dF9kYXRhX2NhdGNoYWxsJykgJiZcbiAgICAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy9fZXJyb3InKSAmJlxuICAgICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnLzQwNCcpXG4gICkge1xuICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgIHJld3JpdGVUYXJnZXQgPSBtYXRjaGVkUGF0aFxuICB9XG5cbiAgaWYgKHJld3JpdGVUYXJnZXQpIHtcbiAgICBpZiAoXG4gICAgICByZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFXG4gICAgKSB7XG4gICAgICBjb25zdCBwYXJzZWRSZXdyaXRlVGFyZ2V0ID0gcGFyc2VSZWxhdGl2ZVVybChyZXdyaXRlVGFyZ2V0KVxuICAgICAgY29uc3QgcGF0aG5hbWVJbmZvID0gZ2V0TmV4dFBhdGhuYW1lSW5mbyhwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lLCB7XG4gICAgICAgIG5leHRDb25maWcsXG4gICAgICAgIHBhcnNlRGF0YTogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIGxldCBmc1BhdGhuYW1lID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZUluZm8ucGF0aG5hbWUpXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSxcbiAgICAgIF0pLnRoZW4oKFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9XTogYW55KSA9PiB7XG4gICAgICAgIGxldCBhcyA9IGFkZExvY2FsZShwYXRobmFtZUluZm8ucGF0aG5hbWUsIHBhdGhuYW1lSW5mby5sb2NhbGUpXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzRHluYW1pY1JvdXRlKGFzKSB8fFxuICAgICAgICAgICghcmV3cml0ZUhlYWRlciAmJlxuICAgICAgICAgICAgcGFnZXMuaW5jbHVkZXMoXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgocmVtb3ZlQmFzZVBhdGgoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKVxuICAgICAgICAgICAgICAgIC5wYXRobmFtZVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gZ2V0TmV4dFBhdGhuYW1lSW5mbyhcbiAgICAgICAgICAgIHBhcnNlUmVsYXRpdmVVcmwoc291cmNlKS5wYXRobmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmV4dENvbmZpZzogcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFU1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgYXMgPSBhZGRCYXNlUGF0aChwYXJzZWRTb3VyY2UucGF0aG5hbWUpXG4gICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IGFzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksXG4gICAgICAgICAgICAocGF0aDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSxcbiAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lXG4gICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWVcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgcmVzdWx0LnBhcnNlZEFzLnF1ZXJ5KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcylcblxuICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9ICFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKVxuICAgICAgICAgID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZShcbiAgICAgICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgICAgICByZW1vdmVCYXNlUGF0aChwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgICAgICAgICkucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHBhZ2VzXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBmc1BhdGhuYW1lXG5cbiAgICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHJlc29sdmVkSHJlZikpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZ2V0Um91dGVNYXRjaGVyKGdldFJvdXRlUmVnZXgocmVzb2x2ZWRIcmVmKSkoYXMpXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCBtYXRjaGVzIHx8IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAncmV3cml0ZScgYXMgY29uc3QsXG4gICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgcmVzb2x2ZWRIcmVmLFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBjb25zdCBzcmMgPSBwYXJzZVBhdGgoc291cmNlKVxuICAgIGNvbnN0IHBhdGhuYW1lID0gZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyh7XG4gICAgICAuLi5nZXROZXh0UGF0aG5hbWVJbmZvKHNyYy5wYXRobmFtZSwgeyBuZXh0Q29uZmlnLCBwYXJzZURhdGE6IHRydWUgfSksXG4gICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgYnVpbGRJZDogJycsXG4gICAgfSlcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgdHlwZTogJ3JlZGlyZWN0LWV4dGVybmFsJyBhcyBjb25zdCxcbiAgICAgIGRlc3RpbmF0aW9uOiBgJHtwYXRobmFtZX0ke3NyYy5xdWVyeX0ke3NyYy5oYXNofWAsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLXJlZGlyZWN0JylcblxuICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICBjb25zdCBzcmMgPSBwYXJzZVBhdGgocmVkaXJlY3RUYXJnZXQpXG4gICAgICBjb25zdCBwYXRobmFtZSA9IGZvcm1hdE5leHRQYXRobmFtZUluZm8oe1xuICAgICAgICAuLi5nZXROZXh0UGF0aG5hbWVJbmZvKHNyYy5wYXRobmFtZSwgeyBuZXh0Q29uZmlnLCBwYXJzZURhdGE6IHRydWUgfSksXG4gICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgIGJ1aWxkSWQ6ICcnLFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIHR5cGU6ICdyZWRpcmVjdC1pbnRlcm5hbCcgYXMgY29uc3QsXG4gICAgICAgIG5ld0FzOiBgJHtwYXRobmFtZX0ke3NyYy5xdWVyeX0ke3NyYy5oYXNofWAsXG4gICAgICAgIG5ld1VybDogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcgYXMgY29uc3QsXG4gICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXQsXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiAnbmV4dCcgYXMgY29uc3QgfSlcbn1cblxuaW50ZXJmYWNlIFdpdGhNaWRkbGV3YXJlRWZmZWN0c091dHB1dCBleHRlbmRzIEZldGNoRGF0YU91dHB1dCB7XG4gIGVmZmVjdDogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBnZXRNaWRkbGV3YXJlRGF0YT4+XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0czxUIGV4dGVuZHMgRmV0Y2hEYXRhT3V0cHV0PihcbiAgb3B0aW9uczogTWlkZGxld2FyZUVmZmVjdFBhcmFtczxUPlxuKTogUHJvbWlzZTxXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXQgfCBudWxsPiB7XG4gIGNvbnN0IG1hdGNoZXMgPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKVxuICBpZiAoIW1hdGNoZXMgfHwgIW9wdGlvbnMuZmV0Y2hEYXRhKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpXG5cbiAgY29uc3QgZWZmZWN0ID0gYXdhaXQgZ2V0TWlkZGxld2FyZURhdGEoZGF0YS5kYXRhSHJlZiwgZGF0YS5yZXNwb25zZSwgb3B0aW9ucylcblxuICByZXR1cm4ge1xuICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgIGpzb246IGRhdGEuanNvbixcbiAgICByZXNwb25zZTogZGF0YS5yZXNwb25zZSxcbiAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgZWZmZWN0LFxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFVybCA9IFVybE9iamVjdCB8IHN0cmluZ1xuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGRvbWFpbkxvY2FsZXM/OiByZWFkb25seSBEb21haW5Mb2NhbGVbXSB8IHVuZGVmaW5lZFxuICBpc0xvY2FsZURvbWFpbjogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdmb3J3YXJkJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICAgIHwgJ2lzUmVhZHknXG4gICAgfCAnaXNQcmV2aWV3J1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUHJpdmF0ZVJvdXRlSW5mbyA9XG4gIHwgKE9taXQ8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnc3R5bGVTaGVldHMnPiAmIHsgaW5pdGlhbDogdHJ1ZSB9KVxuICB8IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mb1xuXG5leHBvcnQgdHlwZSBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbiAgcHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG4gIHJvdXRlPzogc3RyaW5nXG4gIHJlc29sdmVkQXM/OiBzdHJpbmdcbiAgcXVlcnk/OiBQYXJzZWRVcmxRdWVyeVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wcyA9IFBpY2s8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChcbiAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgQXBwOiBBcHBDb21wb25lbnQsXG4gIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4pID0+IFByb21pc2U8dm9pZD5cblxudHlwZSBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrID0gKHN0YXRlOiBOZXh0SGlzdG9yeVN0YXRlKSA9PiBib29sZWFuXG5cbnR5cGUgQ29tcG9uZW50TG9hZENhbmNlbCA9ICgoKSA9PiB2b2lkKSB8IG51bGxcblxudHlwZSBIaXN0b3J5TWV0aG9kID0gJ3JlcGxhY2VTdGF0ZScgfCAncHVzaFN0YXRlJ1xuXG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9XG4gIHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiZcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJlxuICAhIShmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2ID0gJ19fbmV4dCdcbiAgICAgIHJldHVybiAoc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZSlcbiAgICB9IGNhdGNoIChuKSB7fVxuICB9KSgpXG5cbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJylcblxuZnVuY3Rpb24gZmV0Y2hSZXRyeShcbiAgdXJsOiBzdHJpbmcsXG4gIGF0dGVtcHRzOiBudW1iZXIsXG4gIG9wdGlvbnM6IFBpY2s8UmVxdWVzdEluaXQsICdtZXRob2QnIHwgJ2hlYWRlcnMnPlxuKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAneC1uZXh0anMtZGF0YSc6ICcxJyxcbiAgICB9KSxcbiAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gIXJlc3BvbnNlLm9rICYmIGF0dGVtcHRzID4gMSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwXG4gICAgICA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpXG4gICAgICA6IHJlc3BvbnNlXG4gIH0pXG59XG5cbmludGVyZmFjZSBGZXRjaERhdGFPdXRwdXQge1xuICBkYXRhSHJlZjogc3RyaW5nXG4gIGpzb246IFJlY29yZDxzdHJpbmcsIGFueT4gfCBudWxsXG4gIHJlc3BvbnNlOiBSZXNwb25zZVxuICB0ZXh0OiBzdHJpbmdcbiAgY2FjaGVLZXk6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgRmV0Y2hOZXh0RGF0YVBhcmFtcyB7XG4gIGRhdGFIcmVmOiBzdHJpbmdcbiAgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW5cbiAgcGFyc2VKU09OOiBib29sZWFuIHwgdW5kZWZpbmVkXG4gIGhhc01pZGRsZXdhcmU/OiBib29sZWFuXG4gIGluZmxpZ2h0Q2FjaGU6IE5leHREYXRhQ2FjaGVcbiAgcGVyc2lzdENhY2hlOiBib29sZWFuXG4gIGlzUHJlZmV0Y2g6IGJvb2xlYW5cbiAgaXNCYWNrZ3JvdW5kPzogYm9vbGVhblxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG59XG5cbmZ1bmN0aW9uIHRyeVRvUGFyc2VBc0pTT04odGV4dDogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGZldGNoTmV4dERhdGEoe1xuICBkYXRhSHJlZixcbiAgaW5mbGlnaHRDYWNoZSxcbiAgaXNQcmVmZXRjaCxcbiAgaGFzTWlkZGxld2FyZSxcbiAgaXNTZXJ2ZXJSZW5kZXIsXG4gIHBhcnNlSlNPTixcbiAgcGVyc2lzdENhY2hlLFxuICBpc0JhY2tncm91bmQsXG4gIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbn06IEZldGNoTmV4dERhdGFQYXJhbXMpOiBQcm9taXNlPEZldGNoRGF0YU91dHB1dD4ge1xuICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgY29uc3QgZGVwbG95bWVudElkID0gZ2V0RGVwbG95bWVudElkKClcbiAgY29uc3QgZ2V0RGF0YSA9IChwYXJhbXM/OiB7IG1ldGhvZD86ICdIRUFEJyB8ICdHRVQnIH0pID0+XG4gICAgZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30gYXMgSGVhZGVyc0luaXQsXG4gICAgICAgIGlzUHJlZmV0Y2ggPyB7IHB1cnBvc2U6ICdwcmVmZXRjaCcgfSA6IHt9LFxuICAgICAgICBpc1ByZWZldGNoICYmIGhhc01pZGRsZXdhcmUgPyB7ICd4LW1pZGRsZXdhcmUtcHJlZmV0Y2gnOiAnMScgfSA6IHt9LFxuICAgICAgICBkZXBsb3ltZW50SWQgPyB7ICd4LWRlcGxveW1lbnQtaWQnOiBkZXBsb3ltZW50SWQgfSA6IHt9XG4gICAgICApLFxuICAgICAgbWV0aG9kOiBwYXJhbXM/Lm1ldGhvZCA/PyAnR0VUJyxcbiAgICB9KVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiBwYXJhbXM/Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZGF0YUhyZWYsIHJlc3BvbnNlLCB0ZXh0OiAnJywganNvbjoge30sIGNhY2hlS2V5IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGhhc01pZGRsZXdhcmUgJiZcbiAgICAgICAgICAgICAgWzMwMSwgMzAyLCAzMDcsIDMwOF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGRhdGFIcmVmLCByZXNwb25zZSwgdGV4dCwganNvbjoge30sIGNhY2hlS2V5IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgIGlmICh0cnlUb1BhcnNlQXNKU09OKHRleHQpPy5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgIGpzb246IHsgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORCB9LFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzXG4gICAgICAgICAgICAgKiBjYXVzZWQgb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG9cbiAgICAgICAgICAgICAqIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoZXJyb3IpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogcGFyc2VKU09OID8gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSA6IG51bGwsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFwZXJzaXN0Q2FjaGUgfHxcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8XG4gICAgICAgICAgZGF0YS5yZXNwb25zZS5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLWNhY2hlJykgPT09ICduby1jYWNoZSdcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xuICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBjaHJvbWVcbiAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcgfHxcbiAgICAgICAgICAvLyBmaXJlZm94XG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPT09ICdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicgfHxcbiAgICAgICAgICAvLyBzYWZhcmlcbiAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ0xvYWQgZmFpbGVkJ1xuICAgICAgICApIHtcbiAgICAgICAgICBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9KVxuXG4gIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXG4gIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtY2FjaGUnKSAhPT0gJ25vLWNhY2hlJykge1xuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBjYWNoZSBpZiBub3QgbWFya2VkIGFzIG5vLWNhY2hlXG4gICAgICAgIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gUHJvbWlzZS5yZXNvbHZlKGRhdGEpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldXG4gIH1cbiAgcmV0dXJuIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGdldERhdGEoXG4gICAgaXNCYWNrZ3JvdW5kID8geyBtZXRob2Q6ICdIRUFEJyB9IDoge31cbiAgKSlcbn1cblxuaW50ZXJmYWNlIE5leHREYXRhQ2FjaGUge1xuICBbYXNQYXRoOiBzdHJpbmddOiBQcm9taXNlPEZldGNoRGF0YU91dHB1dD5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gIHVybCxcbiAgcm91dGVyLFxufToge1xuICB1cmw6IHN0cmluZ1xuICByb3V0ZXI6IFJvdXRlclxufSkge1xuICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAvLyBVUkwgYXMgdGhpcyBjYW4gZW5kIHVwIHdpdGggYW4gaW5maW5pdGUgcmVmcmVzaFxuICBpZiAodXJsID09PSBhZGRCYXNlUGF0aChhZGRMb2NhbGUocm91dGVyLmFzUGF0aCwgcm91dGVyLmxvY2FsZSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMICR7dXJsfSAke2xvY2F0aW9uLmhyZWZ9YFxuICAgIClcbiAgfVxuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxufVxuXG5jb25zdCBnZXRDYW5jZWxsZWRIYW5kbGVyID0gKHtcbiAgcm91dGUsXG4gIHJvdXRlcixcbn06IHtcbiAgcm91dGU6IHN0cmluZ1xuICByb3V0ZXI6IFJvdXRlclxufSkgPT4ge1xuICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgY29uc3QgY2FuY2VsID0gKHJvdXRlci5jbGMgPSAoKSA9PiB7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZVxuICB9KVxuXG4gIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpID0+IHtcbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICByb3V0ZXIuY2xjID0gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFuZGxlQ2FuY2VsbGVkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU2VydmVyIERhdGEgQ2FjaGUgKGZ1bGwgZGF0YSByZXF1ZXN0cylcbiAgc2RjOiBOZXh0RGF0YUNhY2hlID0ge31cbiAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXG4gIHNiYzogTmV4dERhdGFDYWNoZSA9IHt9XG5cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IFBhZ2VMb2FkZXJcbiAgX2JwczogQmVmb3JlUG9wU3RhdGVDYWxsYmFjayB8IHVuZGVmaW5lZFxuICBldmVudHM6IE1pdHRFbWl0dGVyPFJvdXRlckV2ZW50PlxuICBfd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgX3NoYWxsb3c/OiBib29sZWFuIHwgdW5kZWZpbmVkXG4gIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXSB8IHVuZGVmaW5lZFxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGRvbWFpbkxvY2FsZXM/OiByZWFkb25seSBEb21haW5Mb2NhbGVbXSB8IHVuZGVmaW5lZFxuICBpc1JlYWR5OiBib29sZWFuXG4gIGlzTG9jYWxlRG9tYWluOiBib29sZWFuXG4gIGlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZVxuICBfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZTogUHJvbWlzZTxib29sZWFuPlxuICAvLyBzdGF0aWMgZW50cmllcyBmaWx0ZXJcbiAgX2JmbF9zPzogaW1wb3J0KCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJykuQmxvb21GaWx0ZXJcbiAgLy8gZHluYW1pYyBlbnRpcmVzIGZpbHRlclxuICBfYmZsX2Q/OiBpbXBvcnQoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKS5CbG9vbUZpbHRlclxuXG4gIHByaXZhdGUgc3RhdGU6IFJlYWRvbmx5PHtcbiAgICByb3V0ZTogc3RyaW5nXG4gICAgcGF0aG5hbWU6IHN0cmluZ1xuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAgIGFzUGF0aDogc3RyaW5nXG4gICAgbG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgaXNQcmV2aWV3OiBib29sZWFuXG4gIH0+XG5cbiAgcHJpdmF0ZSBfa2V5OiBzdHJpbmcgPSBjcmVhdGVLZXkoKVxuXG4gIHN0YXRpYyBldmVudHM6IE1pdHRFbWl0dGVyPFJvdXRlckV2ZW50PiA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgICAgbG9jYWxlLFxuICAgICAgbG9jYWxlcyxcbiAgICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgICBkb21haW5Mb2NhbGVzLFxuICAgICAgaXNQcmV2aWV3LFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoV3JhcEFwcENvbXBvbmVudDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiByZWFkb25seSBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IHJlYWRvbmx5IERvbWFpbkxvY2FsZVtdXG4gICAgICBpc1ByZXZpZXc/OiBib29sZWFuXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICBjb25zdCByb3V0ZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICBlcnIsXG4gICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgIENvbXBvbmVudDogQXBwIGFzIENvbXBvbmVudFR5cGUsXG4gICAgICBzdHlsZVNoZWV0czogW1xuICAgICAgICAvKiAvX2FwcCBkb2VzIG5vdCBuZWVkIGl0cyBzdHlsZXNoZWV0cyBtYW5hZ2VkICovXG4gICAgICBdLFxuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXJcbiAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPVxuICAgICAgaXNEeW5hbWljUm91dGUocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0XG5cbiAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJ1xuICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uXG4gICAgdGhpcy5jbGMgPSBudWxsXG4gICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHBcbiAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICB0aGlzLmlzU3NyID0gdHJ1ZVxuICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZVxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5pc0V4cGVyaW1lbnRhbENvbXBpbGUgfHxcbiAgICAgIChzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwKSB8fFxuICAgICAgKCFhdXRvRXhwb3J0RHluYW1pYyAmJlxuICAgICAgICAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiZcbiAgICAgICAgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpXG4gICAgKVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXNcbiAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGVcbiAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXNcbiAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhIWRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICByb3V0ZSxcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcXVlcnksXG4gICAgICBhc1BhdGg6IGF1dG9FeHBvcnREeW5hbWljID8gcGF0aG5hbWUgOiBhcyxcbiAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpXG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICBjb25zdCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHsgbG9jYWxlIH1cbiAgICAgICAgY29uc3QgYXNQYXRoID0gZ2V0VVJMKClcblxuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgYXNQYXRoLFxuICAgICAgICB9KS50aGVuKChtYXRjaGVzKSA9PiB7XG4gICAgICAgICAgLy8gaWYgbWlkZGxld2FyZSBtYXRjaGVzIHdlIGxlYXZlIHJlc29sdmluZyB0byB0aGUgY2hhbmdlIGZ1bmN0aW9uXG4gICAgICAgICAgLy8gYXMgdGhlIHNlcnZlciBuZWVkcyB0byByZXNvbHZlIGZvciBjb3JyZWN0IHByaW9yaXR5XG4gICAgICAgICAgOyhvcHRpb25zIGFzIGFueSkuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lXG5cbiAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgICAgICAgID8gYXNQYXRoXG4gICAgICAgICAgICAgIDogZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlc1xuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLm9uUG9wU3RhdGUpXG5cbiAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgfSA9IHRoaXNcbiAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2VcblxuICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZSBhcyBIaXN0b3J5U3RhdGVcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gdGhpc1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgIGlmIChcbiAgICAgIGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmXG4gICAgICB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiZcbiAgICAgIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGZvcmNlZFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgeyB1cmwsIGFzLCBvcHRpb25zLCBrZXkgfSA9IHN0YXRlXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAvLyBTbmFwc2hvdCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICAgJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSxcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnX19uZXh0X3Njcm9sbF8nICsga2V5KVxuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2ISlcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHsgeDogMCwgeTogMCB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2tleSA9IGtleVxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAoXG4gICAgICB0aGlzLmlzU3NyICYmXG4gICAgICBhcyA9PT0gYWRkQmFzZVBhdGgodGhpcy5hc1BhdGgpICYmXG4gICAgICBwYXRobmFtZSA9PT0gYWRkQmFzZVBhdGgodGhpcy5wYXRobmFtZSlcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlKFxuICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICB1cmwsXG4gICAgICBhcyxcbiAgICAgIE9iamVjdC5hc3NpZ248e30sIFRyYW5zaXRpb25PcHRpb25zLCBUcmFuc2l0aW9uT3B0aW9ucz4oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgIF9oOiAwLFxuICAgICAgfSksXG4gICAgICBmb3JjZWRTY3JvbGxcbiAgICApXG4gIH1cblxuICByZWxvYWQoKTogdm9pZCB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gIH1cblxuICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqL1xuICBiYWNrKCkge1xuICAgIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGZvcndhcmQgaW4gaGlzdG9yeVxuICAgKi9cbiAgZm9yd2FyZCgpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM/OiBVcmwsIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge30pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgICAgICdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHJlcGxhY2UodXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBfYmZsKFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcmVzb2x2ZWRBcz86IHN0cmluZyxcbiAgICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgICBza2lwTmF2aWdhdGU/OiBib29sZWFuXG4gICkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgaWYgKCF0aGlzLl9iZmxfcyAmJiAhdGhpcy5fYmZsX2QpIHtcbiAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciB9ID1cbiAgICAgICAgICByZXF1aXJlKCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpXG5cbiAgICAgICAgdHlwZSBGaWx0ZXIgPSBSZXR1cm5UeXBlPFxuICAgICAgICAgIGltcG9ydCgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpLkJsb29tRmlsdGVyWydleHBvcnQnXVxuICAgICAgICA+XG4gICAgICAgIGxldCBzdGF0aWNGaWx0ZXJEYXRhOiBGaWx0ZXIgfCB1bmRlZmluZWRcbiAgICAgICAgbGV0IGR5bmFtaWNGaWx0ZXJEYXRhOiBGaWx0ZXIgfCB1bmRlZmluZWRcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIDsoe1xuICAgICAgICAgICAgX19yb3V0ZXJGaWx0ZXJTdGF0aWM6IHN0YXRpY0ZpbHRlckRhdGEsXG4gICAgICAgICAgICBfX3JvdXRlckZpbHRlckR5bmFtaWM6IGR5bmFtaWNGaWx0ZXJEYXRhLFxuICAgICAgICAgIH0gPSAoYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKSBhcyBhbnkgYXMge1xuICAgICAgICAgICAgX19yb3V0ZXJGaWx0ZXJTdGF0aWM/OiBGaWx0ZXJcbiAgICAgICAgICAgIF9fcm91dGVyRmlsdGVyRHluYW1pYz86IEZpbHRlclxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGZhaWxlZCB0byBsb2FkIGJ1aWxkIG1hbmlmZXN0IGhhcmQgbmF2aWdhdGVcbiAgICAgICAgICAvLyB0byBiZSBzYWZlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgdXJsOiBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgICAgYWRkTG9jYWxlKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3V0ZXJGaWx0ZXJTVmFsdWU6IEZpbHRlciB8IGZhbHNlID0gcHJvY2Vzcy5lbnZcbiAgICAgICAgICAuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIgYXMgYW55XG5cbiAgICAgICAgaWYgKCFzdGF0aWNGaWx0ZXJEYXRhICYmIHJvdXRlckZpbHRlclNWYWx1ZSkge1xuICAgICAgICAgIHN0YXRpY0ZpbHRlckRhdGEgPSByb3V0ZXJGaWx0ZXJTVmFsdWUgPyByb3V0ZXJGaWx0ZXJTVmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJvdXRlckZpbHRlckRWYWx1ZTogRmlsdGVyIHwgZmFsc2UgPSBwcm9jZXNzLmVudlxuICAgICAgICAgIC5fX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiBhcyBhbnlcblxuICAgICAgICBpZiAoIWR5bmFtaWNGaWx0ZXJEYXRhICYmIHJvdXRlckZpbHRlckRWYWx1ZSkge1xuICAgICAgICAgIGR5bmFtaWNGaWx0ZXJEYXRhID0gcm91dGVyRmlsdGVyRFZhbHVlXG4gICAgICAgICAgICA/IHJvdXRlckZpbHRlckRWYWx1ZVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0aWNGaWx0ZXJEYXRhPy5udW1IYXNoZXMpIHtcbiAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihcbiAgICAgICAgICAgIHN0YXRpY0ZpbHRlckRhdGEubnVtSXRlbXMsXG4gICAgICAgICAgICBzdGF0aWNGaWx0ZXJEYXRhLmVycm9yUmF0ZVxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkeW5hbWljRmlsdGVyRGF0YT8ubnVtSGFzaGVzKSB7XG4gICAgICAgICAgdGhpcy5fYmZsX2QgPSBuZXcgQmxvb21GaWx0ZXIoXG4gICAgICAgICAgICBkeW5hbWljRmlsdGVyRGF0YS5udW1JdGVtcyxcbiAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJEYXRhLmVycm9yUmF0ZVxuICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLl9iZmxfZC5pbXBvcnQoZHluYW1pY0ZpbHRlckRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGNoZXNCZmxTdGF0aWMgPSBmYWxzZVxuICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2VcbiAgICAgIGNvbnN0IHBhdGhzVG9DaGVjazogQXJyYXk8eyBhcz86IHN0cmluZzsgYWxsb3dNYXRjaEN1cnJlbnQ/OiBib29sZWFuIH0+ID1cbiAgICAgICAgW3sgYXMgfSwgeyBhczogcmVzb2x2ZWRBcyB9XVxuXG4gICAgICBmb3IgKGNvbnN0IHsgYXM6IGN1ckFzLCBhbGxvd01hdGNoQ3VycmVudCB9IG9mIHBhdGhzVG9DaGVjaykge1xuICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICBjb25zdCBhc05vU2xhc2ggPSByZW1vdmVUcmFpbGluZ1NsYXNoKFxuICAgICAgICAgICAgbmV3IFVSTChjdXJBcywgJ2h0dHA6Ly9uJykucGF0aG5hbWVcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgYXNOb1NsYXNoTG9jYWxlID0gYWRkQmFzZVBhdGgoXG4gICAgICAgICAgICBhZGRMb2NhbGUoYXNOb1NsYXNoLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWxsb3dNYXRjaEN1cnJlbnQgfHxcbiAgICAgICAgICAgIGFzTm9TbGFzaCAhPT1cbiAgICAgICAgICAgICAgcmVtb3ZlVHJhaWxpbmdTbGFzaChuZXcgVVJMKHRoaXMuYXNQYXRoLCAnaHR0cDovL24nKS5wYXRobmFtZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPVxuICAgICAgICAgICAgICBtYXRjaGVzQmZsU3RhdGljIHx8XG4gICAgICAgICAgICAgICEhdGhpcy5fYmZsX3M/LmNvbnRhaW5zKGFzTm9TbGFzaCkgfHxcbiAgICAgICAgICAgICAgISF0aGlzLl9iZmxfcz8uY29udGFpbnMoYXNOb1NsYXNoTG9jYWxlKVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRBUyBvZiBbYXNOb1NsYXNoLCBhc05vU2xhc2hMb2NhbGVdKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGFueSBzdWItcGF0aCBvZiBhcyBtYXRjaGVzIGEgZHluYW1pYyBmaWx0ZXIgcGF0aFxuICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgY29uc3QgY3VyQXNQYXJ0cyA9IG5vcm1hbGl6ZWRBUy5zcGxpdCgnLycpXG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICFtYXRjaGVzQmZsRHluYW1pYyAmJiBpIDwgY3VyQXNQYXJ0cy5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IGN1ckFzUGFydHMuc2xpY2UoMCwgaSkuam9pbignLycpXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJ0ICYmIHRoaXMuX2JmbF9kPy5jb250YWlucyhjdXJyZW50UGFydCkpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCByb3V0ZXIgZmlsdGVyIGlzIG1hdGNoZWQgdGhlbiB3ZSB0cmlnZ2VyXG4gICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYWRkQmFzZVBhdGgoXG4gICAgICAgICAgICAgICAgICBhZGRMb2NhbGUoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybCwgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSAob3B0aW9ucyBhcyBhbnkpLl9oID09PSAxXG5cbiAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpXG4gICAgfVxuXG4gICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID1cbiAgICAgIGlzUXVlcnlVcGRhdGluZyB8fFxuICAgICAgKG9wdGlvbnMgYXMgYW55KS5fc2hvdWxkUmVzb2x2ZUhyZWYgfHxcbiAgICAgIHBhcnNlUGF0aCh1cmwpLnBhdGhuYW1lID09PSBwYXJzZVBhdGgoYXMpLnBhdGhuYW1lXG5cbiAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnN0YXRlLFxuICAgIH1cblxuICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgIC8vIG9yIGEgbmF2aWdhdGlvbiBoYXMgb2NjdXJyZWRcbiAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlXG4gICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZVxuICAgIGNvbnN0IGlzU3NyID0gdGhpcy5pc1NzclxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cblxuICAgIC8vIGlmIGEgcm91dGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGJlZm9yZVxuICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLmNsYykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgcHJldkxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGVcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBuZXh0U3RhdGUubG9jYWxlID1cbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGVcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gcmVtb3ZlQmFzZVBhdGgoYXMpIDogYXNcbiAgICAgIClcbiAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpXG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICBoYXNCYXNlUGF0aCh1cmwpID8gcmVtb3ZlQmFzZVBhdGgodXJsKSA6IHVybCxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICAgICkucGF0aG5hbWVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2VcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsZXM/LmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUhKSkge1xuICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKVxuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgIHVybDogZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKFxuICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgKVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWROYXZpZ2F0ZSAmJlxuICAgICAgICAgIGRldGVjdGVkRG9tYWluICYmXG4gICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiAmJlxuICAgICAgICAgIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSByZW1vdmVCYXNlUGF0aChhcylcbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICB1cmw6IGBodHRwJHtkZXRlY3RlZERvbWFpbi5odHRwID8gJycgOiAncyd9Oi8vJHtcbiAgICAgICAgICAgICAgZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICAgICB9JHthZGRCYXNlUGF0aChcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgOiBgLyR7bmV4dFN0YXRlLmxvY2FsZX1gXG4gICAgICAgICAgICAgIH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLydcbiAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSwgc2Nyb2xsID0gdHJ1ZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7IHNoYWxsb3cgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFxuICAgICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgICBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksXG4gICAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSxcbiAgICAgICAgICByb3V0ZVByb3BzXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xjKClcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIGFzID0gYWRkQmFzZVBhdGgoXG4gICAgICBhZGRMb2NhbGUoXG4gICAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IHJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgICBvcHRpb25zLmxvY2FsZSxcbiAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICApXG4gICAgKVxuICAgIGNvbnN0IGNsZWFuZWRBcyA9IHJlbW92ZUxvY2FsZShcbiAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IHJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzLFxuICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGVcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNjcm9sbDogZmFsc2UsXG4gICAgICB9KVxuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnNldChuZXh0U3RhdGUsIHRoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChpc0Vycm9yKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGxldCBwYWdlczogc3RyaW5nW10sIHJld3JpdGVzOiBhbnlcbiAgICB0cnkge1xuICAgICAgO1twYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCksXG4gICAgICAgIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSxcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKSxcbiAgICAgIF0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNcblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVRyYWlsaW5nU2xhc2gocmVtb3ZlQmFzZVBhdGgocGF0aG5hbWUpKVxuICAgICAgOiBwYXRobmFtZVxuXG4gICAgbGV0IHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aCgnLycpICYmIHBhcnNlUmVsYXRpdmVVcmwoYXMpLnBhdGhuYW1lXG5cbiAgICAvLyBpZiB3ZSBkZXRlY3RlZCB0aGUgcGF0aCBhcyBhcHAgcm91dGUgZHVyaW5nIHByZWZldGNoaW5nXG4gICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICBpZiAoKHRoaXMuY29tcG9uZW50c1twYXRobmFtZV0gYXMgYW55KT8uX19hcHBSb3V0ZXIpIHtcbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBhcywgcm91dGVyOiB0aGlzIH0pXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgfVxuXG4gICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKFxuICAgICAgcGFyc2VkQXNQYXRobmFtZSAmJlxuICAgICAgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiZcbiAgICAgICghaXNEeW5hbWljUm91dGUocm91dGUpIHx8XG4gICAgICAgICFnZXRSb3V0ZU1hdGNoZXIoZ2V0Um91dGVSZWdleChyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKVxuICAgIClcblxuICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcbiAgICAvLyBtaWRkbGV3YXJlIGFzIHRoZSByZXNvbHZpbmcgd2lsbCBvY2N1ciBzZXJ2ZXItc2lkZVxuICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID1cbiAgICAgICFvcHRpb25zLnNoYWxsb3cgJiZcbiAgICAgIChhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgfSkpXG5cbiAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIDsob3B0aW9ucyBhcyBhbnkpLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWVcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShjbGVhbmVkQXMsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKSxcbiAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAocDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgIHJlc29sdmVkQXMgPSByZXdyaXRlc1Jlc3VsdC5hc1BhdGhcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZlxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKVxuXG4gICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpXG5cbiAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhdGhuYW1lKVxuXG4gICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNMb2NhbFVSTChhcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgK1xuICAgICAgICAgICAgYFxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmVzb2x2ZWRBcyA9IHJlbW92ZUxvY2FsZShyZW1vdmVCYXNlUGF0aChyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSlcblxuICAgIHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBsZXQgcm91dGVNYXRjaDogUGFyYW1zIHwgZmFsc2UgPSBmYWxzZVxuXG4gICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpXG4gICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWVcblxuICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICByb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpXG4gICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lXG4gICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlXG4gICAgICAgID8gaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpXG4gICAgICAgIDogKHt9IGFzIHsgcmVzdWx0OiB1bmRlZmluZWQ7IHBhcmFtczogdW5kZWZpbmVkIH0pXG5cbiAgICAgIGlmICghcm91dGVNYXRjaCB8fCAoc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcmFtKSA9PiAhcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgJiYgIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gYEludGVycG9sYXRpbmcgaHJlZmBcbiAgICAgICAgICAgICAgICAgIDogYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgYFxuICAgICAgICAgICAgICB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgIGB0aGUgcGFyYW1zOiAke21pc3NpbmdQYXJhbXMuam9pbihcbiAgICAgICAgICAgICAgICAgICcsICdcbiAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIChzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICA/IGBUaGUgcHJvdmlkZWQgXFxgaHJlZlxcYCAoJHt1cmx9KSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYFxuICAgICAgICAgICAgICA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICtcbiAgICAgICAgICAgICAgYFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvJHtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgICAgPyAnaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZCdcbiAgICAgICAgICAgICAgICAgIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ1xuICAgICAgICAgICAgICB9YFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRJbnRlcnBvbGF0ZSkge1xuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgcXVlcnk6IG9taXQocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKVxuICAgIH1cblxuICAgIGNvbnN0IGlzRXJyb3JSb3V0ZSA9IHRoaXMucGF0aG5hbWUgPT09ICcvNDA0JyB8fCB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcidcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlLFxuICAgICAgfSlcblxuICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICBhd2FpdCB0aGlzLl9iZmwoXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgJ3Jlc29sdmVkQXMnIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoJ3JvdXRlJyBpbiByb3V0ZUluZm8gJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGVcbiAgICAgICAgcm91dGUgPSBwYXRobmFtZVxuXG4gICAgICAgIGlmICghcm91dGVQcm9wcy5zaGFsbG93KSB7XG4gICAgICAgICAgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCByb3V0ZUluZm8ucXVlcnkgfHwge30sIHF1ZXJ5KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gaGFzQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKVxuICAgICAgICAgID8gcmVtb3ZlQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKVxuICAgICAgICAgIDogcGFyc2VkLnBhdGhuYW1lXG5cbiAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcGF0aG5hbWUgIT09IGNsZWFuZWRQYXJzZWRQYXRobmFtZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcXVlcnlba2V5XSA9PT0gcm91dGVNYXRjaFtrZXldKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmVmaXhlZEFzID1cbiAgICAgICAgICAgICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXNcbiAgICAgICAgICAgICAgPyByb3V0ZUluZm8ucmVzb2x2ZWRBc1xuICAgICAgICAgICAgICA6IGFkZEJhc2VQYXRoKFxuICAgICAgICAgICAgICAgICAgYWRkTG9jYWxlKFxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBc1xuXG4gICAgICAgICAgaWYgKGhhc0Jhc2VQYXRoKHJld3JpdGVBcykpIHtcbiAgICAgICAgICAgIHJld3JpdGVBcyA9IHJlbW92ZUJhc2VQYXRoKHJld3JpdGVBcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChyZXdyaXRlQXMsIHRoaXMubG9jYWxlcylcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHBhdGhuYW1lKVxuICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoXG4gICAgICAgICAgICBuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWVcbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbiwgcm91dGVyOiB0aGlzIH0pXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudDogYW55ID0gcm91dGVJbmZvLkNvbXBvbmVudFxuICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXS5jb25jYXQoY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKVxuXG4gICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0OiBhbnkpID0+IHtcbiAgICAgICAgICBoYW5kbGVDbGllbnRTY3JpcHRMb2FkKHNjcmlwdC5wcm9wcylcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMgJiZcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZVxuXG4gICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVFxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiZcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoXG4gICAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHBhZ2VzXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwsIGFzOiBuZXdBcyB9ID0gcHJlcGFyZVVybEFzKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiBkZXN0aW5hdGlvbiwgcm91dGVyOiB0aGlzIH0pXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dFN0YXRlLmlzUHJldmlldyA9ICEhcm91dGVJbmZvLnByb3BzLl9fTl9QUkVWSUVXXG5cbiAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICByb3V0ZVByb3BzOiB7IHNoYWxsb3c6IGZhbHNlIH0sXG4gICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGlzUXVlcnlVcGRhdGluZyAmJlxuICAgICAgICB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcicgJiZcbiAgICAgICAgc2VsZi5fX05FWFRfREFUQV9fLnByb3BzPy5wYWdlUHJvcHM/LnN0YXR1c0NvZGUgPT09IDUwMCAmJlxuICAgICAgICByb3V0ZUluZm8ucHJvcHM/LnBhZ2VQcm9wc1xuICAgICAgKSB7XG4gICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMFxuICAgICAgfVxuXG4gICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID1cbiAgICAgICAgb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKHJvdXRlSW5mby5yb3V0ZSA/PyByb3V0ZSlcblxuICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID1cbiAgICAgICAgb3B0aW9ucy5zY3JvbGwgPz8gKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzVmFsaWRTaGFsbG93Um91dGUpXG4gICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHsgeDogMCwgeTogMCB9IDogbnVsbFxuICAgICAgY29uc3QgdXBjb21pbmdTY3JvbGxTdGF0ZSA9IGZvcmNlZFNjcm9sbCA/PyByZXNldFNjcm9sbFxuXG4gICAgICAvLyB0aGUgbmV3IHN0YXRlIHRoYXQgdGhlIHJvdXRlciBnb25uYSBzZXRcbiAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSB7XG4gICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlLFxuICAgICAgfVxuXG4gICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgIHBhdGhuYW1lOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgcm91dGVQcm9wczogeyBzaGFsbG93OiBmYWxzZSB9LFxuICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAke3RoaXMucGF0aG5hbWV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcicgJiZcbiAgICAgICAgICBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHM/LnBhZ2VQcm9wcz8uc3RhdHVzQ29kZSA9PT0gNTAwICYmXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzPy5wYWdlUHJvcHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMFxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChpc0Vycm9yKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdiZWZvcmVIaXN0b3J5Q2hhbmdlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucylcblxuICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPVxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmcgJiZcbiAgICAgICAgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiZcbiAgICAgICAgIXJlYWR5U3RhdGVDaGFuZ2UgJiZcbiAgICAgICAgIWxvY2FsZUNoYW5nZSAmJlxuICAgICAgICBjb21wYXJlUm91dGVyU3RhdGVzKHVwY29taW5nUm91dGVyU3RhdGUsIHRoaXMuc3RhdGUpXG5cbiAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlXG4gICAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm91dGVJbmZvLmVycm9yKSB7XG4gICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcbiAgICAgICAgICAgICAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAgICAgICAgICAgICByb3V0ZUluZm8uZXJyb3IsXG4gICAgICAgICAgICAgIGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgcm91dGVQcm9wc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgaGFzaCBtYXJrICMgaXMgdGhlIG9wdGlvbmFsIGxhc3QgcGFydCBvZiBhIFVSTFxuICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC9cbiAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzRXJyb3IoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fVxuICApOiB2b2lkIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS4ke21ldGhvZH0gaXMgbm90IGF2YWlsYWJsZWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IGdldFVSTCgpICE9PSBhcykge1xuICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvd1xuICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXShcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICBrZXk6ICh0aGlzLl9rZXkgPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KCkpLFxuICAgICAgICB9IGFzIEhpc3RvcnlTdGF0ZSxcbiAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICcnLFxuICAgICAgICBhc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgIGVycjogRXJyb3IgJiB7IGNvZGU/OiBhbnk7IGNhbmNlbGxlZD86IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllcyxcbiAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICApOiBQcm9taXNlPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKGlzQXNzZXRFcnJvcihlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgfSlcblxuICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpXG4gICAgfVxuXG4gICAgY29uc29sZS5lcnJvcihlcnIpXG5cbiAgICB0cnkge1xuICAgICAgbGV0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkXG4gICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9XG4gICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgIGVycixcbiAgICAgICAgZXJyb3I6IGVycixcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgICAgICBpc0Vycm9yKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Um91dGVJbmZvKHtcbiAgICByb3V0ZTogcmVxdWVzdGVkUm91dGUsXG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnksXG4gICAgYXMsXG4gICAgcmVzb2x2ZWRBcyxcbiAgICByb3V0ZVByb3BzLFxuICAgIGxvY2FsZSxcbiAgICBoYXNNaWRkbGV3YXJlLFxuICAgIGlzUHJldmlldyxcbiAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgaXNRdWVyeVVwZGF0aW5nLFxuICAgIGlzTWlkZGxld2FyZVJld3JpdGUsXG4gICAgaXNOb3RGb3VuZCxcbiAgfToge1xuICAgIHJvdXRlOiBzdHJpbmdcbiAgICBwYXRobmFtZTogc3RyaW5nXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gICAgYXM6IHN0cmluZ1xuICAgIHJlc29sdmVkQXM6IHN0cmluZ1xuICAgIGhhc01pZGRsZXdhcmU/OiBib29sZWFuXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzXG4gICAgbG9jYWxlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBpc1ByZXZpZXc6IGJvb2xlYW5cbiAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG4gICAgaXNRdWVyeVVwZGF0aW5nPzogYm9vbGVhblxuICAgIGlzTWlkZGxld2FyZVJld3JpdGU/OiBib29sZWFuXG4gICAgaXNOb3RGb3VuZD86IGJvb2xlYW5cbiAgfSkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi9cbiAgICBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBleGlzdGluZ0luZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiB0aGlzLnJvdXRlID09PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdJbmZvXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoeyByb3V0ZSwgcm91dGVyOiB0aGlzIH0pXG5cbiAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBsZXQgY2FjaGVkUm91dGVJbmZvID1cbiAgICAgICAgZXhpc3RpbmdJbmZvICYmXG4gICAgICAgICEoJ2luaXRpYWwnIGluIGV4aXN0aW5nSW5mbykgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCdcbiAgICAgICAgICA/IGV4aXN0aW5nSW5mb1xuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZ1xuICAgICAgY29uc3QgZmV0Y2hOZXh0RGF0YVBhcmFtczogRmV0Y2hOZXh0RGF0YVBhcmFtcyA9IHtcbiAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgaHJlZjogZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gJy80MDQnIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICBsb2NhbGUsXG4gICAgICAgIH0pLFxuICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgIGlzQmFja2dyb3VuZCxcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGE6XG4gICAgICAgIHwgV2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0XG4gICAgICAgIHwgKFBpY2s8V2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0LCAnanNvbic+ICZcbiAgICAgICAgICAgIE9taXQ8UGFydGlhbDxXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXQ+LCAnanNvbic+KVxuICAgICAgICB8IG51bGwgPVxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGVcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgIGZldGNoRGF0YTogKCkgPT4gZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gJy80MDQnIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XG4gICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgIH0pXG5cbiAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAvLyBlZmZlY3RzXG4gICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09ICcvX2Vycm9yJyB8fCBwYXRobmFtZSA9PT0gJy80MDQnKSkge1xuICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSB7IGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaGFuZGxlQ2FuY2VsbGVkKClcblxuICAgICAgaWYgKFxuICAgICAgICBkYXRhPy5lZmZlY3Q/LnR5cGUgPT09ICdyZWRpcmVjdC1pbnRlcm5hbCcgfHxcbiAgICAgICAgZGF0YT8uZWZmZWN0Py50eXBlID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhPy5lZmZlY3Q/LnR5cGUgPT09ICdyZXdyaXRlJykge1xuICAgICAgICBjb25zdCByZXNvbHZlZFJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpXG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcblxuICAgICAgICAvLyBkdXJpbmcgcXVlcnkgdXBkYXRpbmcgdGhlIHBhZ2UgbXVzdCBtYXRjaCBhbHRob3VnaCBkdXJpbmdcbiAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAvLyB3aGljaCBpcyB2YWxpZCBmb3IgaW5jcmVtZW50YWwgbWlncmF0aW9uXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgcm91dGUgPSByZXNvbHZlZFJvdXRlXG4gICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgICBxdWVyeSA9IHsgLi4ucXVlcnksIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5IH1cbiAgICAgICAgICByZXNvbHZlZEFzID0gcmVtb3ZlQmFzZVBhdGgoXG4gICAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpXG4gICAgICAgICAgICAgIC5wYXRobmFtZVxuICAgICAgICAgIClcblxuICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJvdXRlUHJvcHMuc2hhbGxvdyAmJlxuICAgICAgICAgICAgZXhpc3RpbmdJbmZvICYmXG4gICAgICAgICAgICB0aGlzLnJvdXRlID09PSByb3V0ZSAmJlxuICAgICAgICAgICAgIWhhc01pZGRsZXdhcmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgcmV0dXJuIHsgLi4uZXhpc3RpbmdJbmZvLCByb3V0ZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FQSVJvdXRlKHJvdXRlKSkge1xuICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8bmV2ZXI+KCgpID0+IHt9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm8gPVxuICAgICAgICBjYWNoZWRSb3V0ZUluZm8gfHxcbiAgICAgICAgKGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW48Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPihcbiAgICAgICAgICAocmVzKSA9PiAoe1xuICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICBfX05fU1NHOiByZXMubW9kLl9fTl9TU0csXG4gICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgfSlcbiAgICAgICAgKSlcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9XG4gICAgICAgICAgcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJykgYXMgdHlwZW9mIGltcG9ydCgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJylcbiAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNCYWlsZWRQcmVmZXRjaCA9IGRhdGE/LnJlc3BvbnNlPy5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXNraXAnKVxuXG4gICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUFxuXG4gICAgICAvLyBGb3Igbm9uLVNTRyBwcmVmZXRjaGVzIHRoYXQgYmFpbGVkIGJlZm9yZSBzZW5kaW5nIGRhdGFcbiAgICAgIC8vIHdlIGNsZWFyIHRoZSBjYWNoZSB0byBmZXRjaCBmdWxsIHJlc3BvbnNlXG4gICAgICBpZiAod2FzQmFpbGVkUHJlZmV0Y2ggJiYgZGF0YT8uZGF0YUhyZWYpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2RhdGEuZGF0YUhyZWZdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcHJvcHMsIGNhY2hlS2V5IH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhPy5qc29uICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksIHByb3BzOiBkYXRhLmpzb24gfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gZGF0YT8uZGF0YUhyZWZcbiAgICAgICAgICAgID8gZGF0YS5kYXRhSHJlZlxuICAgICAgICAgICAgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgIGhyZWY6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge30sXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICByb3V0ZUluZm8uQ29tcG9uZW50LFxuICAgICAgICAgICAgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgfSBhcyBhbnlcbiAgICAgICAgICApLFxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZGNbY2FjaGVLZXldXG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmlzUHJldmlldyAmJlxuICAgICAgICByb3V0ZUluZm8uX19OX1NTRyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgICAhaXNRdWVyeVVwZGF0aW5nXG4gICAgICApIHtcbiAgICAgICAgZmV0Y2hOZXh0RGF0YShcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XG4gICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zYmMsXG4gICAgICAgICAgfSlcbiAgICAgICAgKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgIH1cblxuICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKVxuICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHNcbiAgICAgIHJvdXRlSW5mby5yb3V0ZSA9IHJvdXRlXG4gICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeVxuICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG5cbiAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKFxuICAgICAgICBnZXRQcm9wZXJFcnJvcihlcnIpLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICByb3V0ZVByb3BzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXQoXG4gICAgc3RhdGU6IHR5cGVvZiB0aGlzLnN0YXRlLFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlXG5cbiAgICByZXR1cm4gdGhpcy5zdWIoXG4gICAgICBkYXRhLFxuICAgICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCBhcyBBcHBDb21wb25lbnQsXG4gICAgICByZXNldFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJywgMilcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJywgMilcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaCA9ICcnXSA9IGFzLnNwbGl0KCcjJywgMilcblxuICAgIGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjb2RlIGhhc2ggdG8gbWFrZSBub24tbGF0aW4gYW5jaG9yIHdvcmtzLlxuICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpXG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKVxuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUocmF3SGFzaClbMF1cbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG9ubHlIYXNoQ2hhbmdlOiB0aGlzLm9ubHlBSGFzaENoYW5nZShhcyksXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi9cbiAgYXN5bmMgcHJlZmV0Y2goXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcgPSB1cmwsXG4gICAgb3B0aW9uczogUHJlZmV0Y2hPcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNCb3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAvLyBsaW5rcyB2aWEgdGhlIGVxdWl2YWxlbnQgb2YgYSBoYXJkIG5hdmlnYXRpb24gYW5kIGhlbmNlIG5ldmVyIHV0aWxpemUgdGhlc2VcbiAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lXG5cbiAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZFxuICAgIGNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBwYXRobmFtZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIGlmIChvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcGF0aG5hbWUgPSBub3JtYWxpemVMb2NhbGVQYXRoIShwYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG5cbiAgICAgICAgbGV0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoIShcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgKVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWVcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICBhc1BhdGggPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGhcblxuICAgIGNvbnN0IGxvY2FsZSA9XG4gICAgICB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkXG4gICAgICAgIDogdGhpcy5sb2NhbGVcblxuICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICB9KVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgbGV0IHJld3JpdGVzOiBhbnlcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuXG4gICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgYWRkQmFzZVBhdGgoYWRkTG9jYWxlKGFzUGF0aCwgdGhpcy5sb2NhbGUpLCB0cnVlKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBwYXJzZWQucXVlcnksXG4gICAgICAgIChwOiBzdHJpbmcpID0+IHJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICByZXNvbHZlZEFzID0gcmVtb3ZlTG9jYWxlKFxuICAgICAgICAgIHJlbW92ZUJhc2VQYXRoKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksXG4gICAgICAgICAgdGhpcy5sb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcblxuICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcylcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBnZXRSb3V0ZU1hdGNoZXIoZ2V0Um91dGVSZWdleChwYXJzZWQucGF0aG5hbWUpKShcbiAgICAgICAgICBwYXJzZVBhdGgoYXNQYXRoKS5wYXRobmFtZVxuICAgICAgICApIHx8IHt9XG4gICAgICApXG5cbiAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09ICdzdHJpY3QnXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICBmZXRjaERhdGE6ICgpID0+XG4gICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgaHJlZjogZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgfSlcblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovXG4gICAgaWYgKGRhdGE/LmVmZmVjdC50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZlxuICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWZcbiAgICAgIHF1ZXJ5ID0geyAuLi5xdWVyeSwgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnkgfVxuICAgICAgcmVzb2x2ZWRBcyA9IGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lXG4gICAgICB1cmwgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSByZWRpcmVjdCB0byBhbiBleHRlcm5hbCBkZXN0aW5hdGlvbiB0aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgKiB0byBwcmVmZXRjaCBjb250ZW50IGFzIGl0IHdpbGwgYmUgdW51c2VkLlxuICAgICAqL1xuICAgIGlmIChkYXRhPy5lZmZlY3QudHlwZSA9PT0gJ3JlZGlyZWN0LWV4dGVybmFsJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHsgX19hcHBSb3V0ZXI6IHRydWUgfSBhcyBhbnlcbiAgICB9XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZykgPT4ge1xuICAgICAgICByZXR1cm4gaXNTc2dcbiAgICAgICAgICA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICBkYXRhSHJlZjogZGF0YT8uanNvblxuICAgICAgICAgICAgICAgID8gZGF0YT8uZGF0YUhyZWZcbiAgICAgICAgICAgICAgICA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHxcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5wcmlvcml0eSAmJlxuICAgICAgICAgICAgICAgICAgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gZmFsc2UpXG4gICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSlcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZykge1xuICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoeyByb3V0ZSwgcm91dGVyOiB0aGlzIH0pXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuICAgICAgaGFuZGxlQ2FuY2VsbGVkKClcblxuICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlQ2FuY2VsbGVkKClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBhbnk+PiB7XG4gICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddXG4gICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwIGFzIEFwcENvbXBvbmVudClcbiAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWVcbiAgICByZXR1cm4gbG9hZEdldEluaXRpYWxQcm9wczxBcHBDb250ZXh0VHlwZTxSb3V0ZXI+PihBcHAsIHtcbiAgICAgIEFwcFRyZWUsXG4gICAgICBDb21wb25lbnQsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICBjdHgsXG4gICAgfSlcbiAgfVxuXG4gIGdldCByb3V0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlXG4gIH1cblxuICBnZXQgcGF0aG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZVxuICB9XG5cbiAgZ2V0IHF1ZXJ5KCk6IFBhcnNlZFVybFF1ZXJ5IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeVxuICB9XG5cbiAgZ2V0IGFzUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aFxuICB9XG5cbiAgZ2V0IGxvY2FsZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZVxuICB9XG5cbiAgZ2V0IGlzRmFsbGJhY2soKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFja1xuICB9XG5cbiAgZ2V0IGlzUHJldmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXdcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUtleSIsIlJvdXRlciIsIm1hdGNoZXNNaWRkbGV3YXJlIiwicmVzb2x2ZVJld3JpdGVzIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJyZXF1aXJlIiwiZGVmYXVsdCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJPYmplY3QiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJtYXRjaGVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXRobmFtZSIsImFzUGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJjbGVhbmVkQXMiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwicmVzb2x2ZUhyZWYiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0IiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiTUFUQ0hFRF9QQVRIX0hFQURFUiIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJhbGwiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwiX19yZXdyaXRlcyIsInJld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsInVuZGVmaW5lZCIsInJlc3VsdCIsInF1ZXJ5IiwicGF0aCIsIm1hdGNoZWRQYWdlIiwicGFyc2VkQXMiLCJyZXNvbHZlZFBhdGhuYW1lIiwibWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInR5cGUiLCJzcmMiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJkZXN0aW5hdGlvbiIsImhhc2giLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZmV0Y2hEYXRhIiwiZGF0YSIsImVmZmVjdCIsImRhdGFIcmVmIiwianNvbiIsInRleHQiLCJjYWNoZUtleSIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJmZXRjaE5leHREYXRhIiwiaW5mbGlnaHRDYWNoZSIsImlzUHJlZmV0Y2giLCJoYXNNaWRkbGV3YXJlIiwiaXNTZXJ2ZXJSZW5kZXIiLCJwYXJzZUpTT04iLCJwZXJzaXN0Q2FjaGUiLCJpc0JhY2tncm91bmQiLCJ1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUiLCJocmVmIiwiVVJMIiwibG9jYXRpb24iLCJkZXBsb3ltZW50SWQiLCJnZXREZXBsb3ltZW50SWQiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsIm5vdEZvdW5kIiwibWFya0Fzc2V0RXJyb3IiLCJOT0RFX0VOViIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwicm91dGUiLCJjYW5jZWwiLCJjbGMiLCJoYW5kbGVDYW5jZWxsZWQiLCJldmVudHMiLCJtaXR0IiwiY29uc3RydWN0b3IiLCJpbml0aWFsUHJvcHMiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJzZGMiLCJzYmMiLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIl9rZXkiLCJvblBvcFN0YXRlIiwiZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsImdldFVSTCIsIl9fTkEiLCJyZWxvYWQiLCJfX04iLCJmb3JjZWRTY3JvbGwiLCJrZXkiLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0SXRlbSIsImlzU3NyIiwiX2JwcyIsImNoYW5nZSIsInNoYWxsb3ciLCJfc2hhbGxvdyIsIl9oIiwiY29tcG9uZW50cyIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwic3R5bGVTaGVldHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImlzRXhwZXJpbWVudGFsQ29tcGlsZSIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwicmVwbGFjZSIsIl9iZmwiLCJza2lwTmF2aWdhdGUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCIsIl9iZmxfcyIsIl9iZmxfZCIsIkJsb29tRmlsdGVyIiwic3RhdGljRmlsdGVyRGF0YSIsImR5bmFtaWNGaWx0ZXJEYXRhIiwiX19yb3V0ZXJGaWx0ZXJTdGF0aWMiLCJfX3JvdXRlckZpbHRlckR5bmFtaWMiLCJjb25zb2xlIiwicm91dGVyRmlsdGVyU1ZhbHVlIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJyb3V0ZXJGaWx0ZXJEVmFsdWUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiIsIm51bUhhc2hlcyIsIm51bUl0ZW1zIiwiZXJyb3JSYXRlIiwiaW1wb3J0IiwibWF0Y2hlc0JmbFN0YXRpYyIsIm1hdGNoZXNCZmxEeW5hbWljIiwicGF0aHNUb0NoZWNrIiwiY3VyQXMiLCJhbGxvd01hdGNoQ3VycmVudCIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsImNvbnRhaW5zIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsInNwbGl0IiwiaSIsImN1cnJlbnRQYXJ0Iiwiam9pbiIsImlzTG9jYWxVUkwiLCJpc1F1ZXJ5VXBkYXRpbmciLCJzaG91bGRSZXNvbHZlSHJlZiIsIm5leHRTdGF0ZSIsInJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2TG9jYWxlIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwiZGlkTmF2aWdhdGUiLCJkZXRlY3RlZERvbWFpbiIsImRvbWFpbiIsImFzTm9CYXNlUGF0aCIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJfaW5GbGlnaHRSb3V0ZSIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJsb2NhbGVDaGFuZ2UiLCJvbmx5QUhhc2hDaGFuZ2UiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJpc0Vycm9yIiwicGFyc2VkIiwidXJsSXNOZXciLCJwYXJzZWRBc1BhdGhuYW1lIiwiX19hcHBSb3V0ZXIiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwibWlzc2luZ1BhcmFtcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJwYXJhbSIsIm9wdGlvbmFsIiwid2FybiIsIm9taXQiLCJpc0Vycm9yUm91dGUiLCJyb3V0ZUluZm8iLCJnZXRSb3V0ZUluZm8iLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJmb3JFYWNoIiwicHJlZml4ZWRBcyIsInJld3JpdGVBcyIsImxvY2FsZVJlc3VsdCIsImN1clJvdXRlTWF0Y2giLCJjb21wb25lbnQiLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJzY3JpcHRzIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJub3RGb3VuZFJvdXRlIiwiZmV0Y2hDb21wb25lbnQiLCJfIiwiaXNOb3RGb3VuZCIsInN0YXR1c0NvZGUiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwic2hvdWxkU2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1Njcm9sbFN0YXRlIiwidXBjb21pbmdSb3V0ZXJTdGF0ZSIsImNhblNraXBVcGRhdGluZyIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYXNoUmVnZXgiLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJyZXF1ZXN0ZWRSb3V0ZSIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwicmVzb2x2ZWRSb3V0ZSIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsInNob3VsZEZldGNoRGF0YSIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiZGlzYWJsZVNtb290aFNjcm9sbER1cmluZ1JvdXRlVHJhbnNpdGlvbiIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvbmx5SGFzaENoYW5nZSIsInByZWZldGNoIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXRobmFtZSIsIm9yaWdpbmFsUGF0aG5hbWUiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});